---
phase: 05-vibe-scanner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/scanner.ts
  - src/lib/scanners.ts
  - src/app/api/scanners/route.ts
  - src/app/api/scanners/[id]/route.ts
  - src/app/api/scanners/generate-query/route.ts
autonomous: true

must_haves:
  truths:
    - "Scanner model supports three types: rfp, meetings, buyers"
    - "Each scanner stores a name, description, search query, type-specific filters, and AI column definitions"
    - "Scanner has embedded score arrays per AI column (not single vibeScore)"
    - "AI can generate a search query from company profile"
    - "CRUD APIs exist for scanner create, read, update, delete, and list"
  artifacts:
    - path: "src/models/scanner.ts"
      provides: "Scanner Mongoose model with multi-type support, columns, scores, filters"
      contains: "scannerSchema"
    - path: "src/lib/scanners.ts"
      provides: "Scanner CRUD, query generation, column management library functions"
      exports: ["createScanner", "getScannerById", "getUserScanners", "updateScanner", "deleteScanner", "generateSearchQuery", "addAiColumn"]
    - path: "src/app/api/scanners/route.ts"
      provides: "GET (list user scanners) and POST (create scanner) endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/scanners/[id]/route.ts"
      provides: "GET (single scanner), PATCH (update), DELETE (remove) endpoints"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/scanners/generate-query/route.ts"
      provides: "POST endpoint that generates search query from company profile via Claude"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/scanners/route.ts"
      to: "src/lib/scanners.ts"
      via: "createScanner and getUserScanners"
      pattern: "createScanner|getUserScanners"
    - from: "src/lib/scanners.ts"
      to: "src/models/scanner.ts"
      via: "Mongoose model operations"
      pattern: "Scanner\\."
    - from: "src/app/api/scanners/generate-query/route.ts"
      to: "src/lib/anthropic.ts"
      via: "Claude Haiku API call for query generation"
      pattern: "anthropic\\.messages\\.create"
---

<objective>
Create the Scanner Mongoose model supporting three scanner types (RFPs, Board Meetings, Buyers) with AI column definitions and per-column score storage, plus CRUD API endpoints and AI-powered search query generation.

Purpose: This is the data foundation for the entire multi-scanner architecture. Every subsequent plan depends on this model and these APIs. The model must support multiple named scanners per user, each with a type, search query, filters, and customizable AI columns.

Output: Scanner model in MongoDB, library functions for all scanner operations, REST API endpoints for CRUD + query generation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-vibe-scanner/05-CONTEXT.md
@.planning/phases/05-vibe-scanner/05-RESEARCH.md
@.planning/phases/05-vibe-scanner/05-01-SUMMARY.md

# Key source files to reference
@src/models/vibe-scanner.ts              # Old single-scanner model (will be replaced)
@src/lib/vibe-scanner.ts                 # Old prompt generation (reuse generateScoringPrompt pattern)
@src/models/contract.ts                  # Contract schema
@src/models/buyer.ts                     # Buyer schema
@src/models/signal.ts                    # Signal schema (for meetings scanner data source)
@src/models/company-profile.ts           # CompanyProfile for query generation
@src/lib/anthropic.ts                    # Anthropic client singleton
@src/lib/contracts.ts                    # Data access layer pattern
@src/app/api/vibe-scanner/route.ts       # Existing scanner API pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scanner Mongoose model with multi-type support and AI column definitions</name>
  <files>src/models/scanner.ts</files>
  <action>
**Create Scanner Mongoose model** at `src/models/scanner.ts`.

This replaces the old single-scanner `vibe-scanner.ts` model. Follow the established model pattern (mongoose.models.X || mongoose.model()).

**Scanner types enum:**
```typescript
export const SCANNER_TYPES = ["rfp", "meetings", "buyers"] as const;
export type ScannerType = typeof SCANNER_TYPES[number];
```

**AI Column subdocument schema** (`aiColumnSchema`):
- `columnId`: String, required (nanoid-generated, unique within scanner)
- `name`: String, required (e.g., "Vibe Score", "Bid Recommendation")
- `prompt`: String, required (the scoring prompt for this column)
- `isDefault`: Boolean, default true (system-generated vs user-created)
- `createdAt`: Date, default Date.now

**Column Score subdocument schema** (`columnScoreSchema`):
- `columnId`: String, required (references aiColumnSchema.columnId)
- `entityId`: Schema.Types.ObjectId, required (references Contract, Buyer, or Signal depending on scanner type)
- `score`: Number, min 0, max 10
- `response`: String, required (full AI response text -- could be score+reasoning or freeform text)
- `reasoning`: String (extracted reasoning for tooltip display)
- `scoredAt`: Date, default Date.now
Use `_id: false` on this subdocument.

**Type-specific filter schemas:**
- RFP filters: `{ sector?: string, region?: string, minValue?: number, maxValue?: number, deadline?: Date }`
- Meetings filters: `{ signalType?: string, orgSector?: string, dateFrom?: Date, dateTo?: Date }`
- Buyers filters: `{ sector?: string, region?: string }`

Store filters as a Mixed type (Schema.Types.Mixed) since they vary by type. Validate on the application layer.

**Main Scanner schema:**
- `userId`: String, required, index (Clerk user ID)
- `name`: String, required (scanner name, user-editable)
- `description`: String (scanner description, user-editable)
- `type`: String, enum SCANNER_TYPES, required, index
- `searchQuery`: String (AI-generated OR-joined conditions, user-editable)
- `filters`: Schema.Types.Mixed, default {} (type-specific filters)
- `aiColumns`: [aiColumnSchema] (array of AI column definitions)
- `scores`: [columnScoreSchema] (flat array of all scores across all columns)
- `lastScoredAt`: Date
- `scoringPrompt`: String (the base scoring prompt generated from company profile -- reuse from old vibe-scanner)
- `companyProfileId`: Schema.Types.ObjectId, ref "CompanyProfile"
- timestamps: true

**Indexes:**
- `{ userId: 1, type: 1 }` compound
- `{ userId: 1, createdAt: -1 }` for list sorting
- `{ "scores.columnId": 1, "scores.entityId": 1 }` for score lookups

**Export:** `IScanner` type via InferSchemaType, default export Scanner model.

**Default AI columns per type** (defined as exported constants):

```typescript
export const DEFAULT_AI_COLUMNS: Record<ScannerType, Array<{ name: string; promptTemplate: string }>> = {
  rfp: [
    { name: "Vibe Score", promptTemplate: "Rate how well this contract matches the company profile on a scale of 1-10. Consider sector alignment, capabilities match, geographic relevance, contract value appropriateness, and certification requirements." },
    { name: "Bid Recommendation", promptTemplate: "Based on the company profile, provide a brief bid recommendation: STRONG BID, CONSIDER, or SKIP. Explain in 1-2 sentences why." },
  ],
  meetings: [
    { name: "Relevance Score", promptTemplate: "Rate how relevant this board meeting signal is to the company profile on a scale of 1-10. Consider whether the discussed topic relates to the company's sectors, capabilities, or target buyers." },
    { name: "Buying Intent", promptTemplate: "Analyze this board meeting signal and rate the buying intent from 1-10. Look for procurement language, budget allocation, strategy shifts, or staffing changes that suggest upcoming purchasing decisions." },
  ],
  buyers: [
    { name: "Account Score", promptTemplate: "Rate how valuable this buyer organization is as a potential account for the company on a scale of 1-10. Consider sector fit, geographic proximity, contract volume, and strategic alignment." },
    { name: "Key Contact", promptTemplate: "Based on the buyer organization's sector and the company profile, describe the ideal contact role to pursue (e.g., 'Head of Procurement', 'IT Director'). Keep to 1 sentence." },
  ],
};
```
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Check that the model file exports Scanner, IScanner, SCANNER_TYPES, ScannerType, and DEFAULT_AI_COLUMNS.
  </verify>
  <done>
Scanner model exists with multi-type support (rfp, meetings, buyers), AI column definitions, per-column score storage, type-specific filter support, and default AI column templates. Build passes with correct type exports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scanner CRUD library, API endpoints, and AI query generation</name>
  <files>src/lib/scanners.ts, src/app/api/scanners/route.ts, src/app/api/scanners/[id]/route.ts, src/app/api/scanners/generate-query/route.ts</files>
  <action>
**1. Create scanner library** at `src/lib/scanners.ts`:

Import dbConnect, Scanner model, CompanyProfile model, anthropic client.

**Core CRUD functions:**

`createScanner(userId: string, data: { name: string; description?: string; type: ScannerType; searchQuery?: string; filters?: Record<string, unknown> }): Promise<IScanner>`:
- Calls dbConnect()
- Creates Scanner document with the provided data
- Adds default AI columns for the scanner type (from DEFAULT_AI_COLUMNS) with nanoid-generated columnIds
- Generates scoringPrompt from CompanyProfile if available (reuse generateScoringPrompt from old lib)
- Returns created scanner

`getUserScanners(userId: string): Promise<IScanner[]>`:
- Calls dbConnect()
- Returns all scanners for user sorted by createdAt descending
- Use `.select('-scores -scoringPrompt')` for list view (don't load heavy data)

`getScannerById(scannerId: string, userId: string): Promise<IScanner | null>`:
- Calls dbConnect()
- Finds by _id and verifies userId matches
- Returns full scanner document with scores

`updateScanner(scannerId: string, userId: string, data: Partial<{ name: string; description: string; searchQuery: string; filters: Record<string, unknown> }>): Promise<IScanner | null>`:
- Calls dbConnect()
- findOneAndUpdate with { _id: scannerId, userId } filter
- Returns updated scanner

`deleteScanner(scannerId: string, userId: string): Promise<boolean>`:
- Calls dbConnect()
- deleteOne with { _id: scannerId, userId }
- Returns true if deleted

`addAiColumn(scannerId: string, userId: string, column: { name: string; prompt: string }): Promise<IScanner | null>`:
- Calls dbConnect()
- Pushes new AI column to scanner's aiColumns array with nanoid columnId, isDefault: false
- Returns updated scanner

**AI query generation function:**

`generateSearchQuery(userId: string, scannerType: ScannerType): Promise<{ name: string; description: string; searchQuery: string }>`:
- Calls dbConnect()
- Loads CompanyProfile for user
- If no profile, return generic defaults per type
- Calls Claude Haiku to generate an OR-joined search query based on company profile + scanner type
- Also generates a scanner name and description
- Uses structured JSON output (output_config)
- System prompt: explain the scanner type context, company profile, and ask for OR-joined search conditions

**Reuse scoring prompt generation:**
Copy the `generateScoringPrompt` function from `src/lib/vibe-scanner.ts` into this file (or import from there -- but since we're replacing the old scanner, copy it here to avoid breaking the old file during transition). Pad to >4096 tokens for Haiku prompt caching.

**2. Create scanner list + create API** at `src/app/api/scanners/route.ts`:

GET handler:
- auth() for userId, 401 if not authenticated
- Call getUserScanners(userId)
- Return `{ scanners }`

POST handler:
- auth() for userId, 401 if not authenticated
- Parse body: `{ name, description, type, searchQuery, filters }`
- Validate type is one of SCANNER_TYPES
- Validate name is non-empty string
- Call createScanner(userId, data)
- Return `{ scanner }` with status 201

**3. Create single scanner API** at `src/app/api/scanners/[id]/route.ts`:

GET handler:
- auth() for userId, 401 if not authenticated
- Get id from params (await params in Next.js 16)
- Call getScannerById(id, userId)
- Return 404 if not found, else `{ scanner }`

PATCH handler:
- auth() for userId, 401 if not authenticated
- Parse body with updatable fields
- Call updateScanner(id, userId, data)
- Return 404 if not found, else `{ scanner }`

DELETE handler:
- auth() for userId, 401 if not authenticated
- Call deleteScanner(id, userId)
- Return 404 if not deleted, else `{ success: true }`

**4. Create query generation API** at `src/app/api/scanners/generate-query/route.ts`:

POST handler:
- auth() for userId, 401 if not authenticated
- Parse body: `{ type: ScannerType }`
- Call generateSearchQuery(userId, type)
- Return `{ name, description, searchQuery }`

Use Claude Haiku with structured output. System prompt should explain:
- Scanner type context (RFP = contracts, Meetings = board minutes signals, Buyers = organizations)
- Company profile data
- Ask for OR-joined conditions like Starbridge (e.g., "discussed intervention strategy OR raised concerns about EHCP support capacity OR...")
- Ask for a descriptive scanner name and description
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify all 4 API route files exist with correct exports. Check that nanoid import works (already in package.json from Phase 3).
  </verify>
  <done>
Scanner CRUD library provides create, read, update, delete, list, and addAiColumn functions. API endpoints handle all scanner operations with auth. Query generation API uses Claude Haiku to generate OR-joined search queries from company profile. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx next build` succeeds with no errors
2. Scanner model exports Scanner, IScanner, SCANNER_TYPES, ScannerType, DEFAULT_AI_COLUMNS
3. Library exports all CRUD functions and generateSearchQuery
4. GET /api/scanners returns user's scanner list
5. POST /api/scanners creates a new scanner with default AI columns
6. GET/PATCH/DELETE /api/scanners/[id] operate on individual scanners
7. POST /api/scanners/generate-query returns AI-generated search query
</verification>

<success_criteria>
- Scanner model supports rfp, meetings, and buyers types with type-specific filters
- Each scanner has customizable AI columns with per-column score storage
- Default AI columns are automatically created per scanner type
- CRUD API endpoints work with auth protection
- AI generates search queries as OR-joined conditions from company profile
- VIBE-01, VIBE-02 requirements partially satisfied (scanner creation and prompt generation)
</success_criteria>

<output>
After completion, create `.planning/phases/05-vibe-scanner/05-01-SUMMARY.md`
</output>
