---
phase: 05-vibe-scanner
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/app/(dashboard)/scanners/[id]/page.tsx
  - src/components/scanners/scanner-table.tsx
  - src/components/scanners/scanner-header.tsx
  - src/components/scanners/table-columns.ts
  - src/stores/scanner-store.ts
autonomous: true

must_haves:
  truths:
    - "User can open a scanner and see a table view with entity-first data columns"
    - "RFP scanner shows: Buyer org name, Contract description, Value, Deadline, Sector, then AI columns"
    - "Meetings scanner shows: Organization name, Signal summary, Signal type, Date, then AI columns"
    - "Buyers scanner shows: Organization name, Description/sector, Contact count, Region, then AI columns"
    - "Table header shows scanner name, type badge, description, and toolbar"
    - "AI column cells show loading skeleton when not yet scored"
  artifacts:
    - path: "src/app/(dashboard)/scanners/[id]/page.tsx"
      provides: "Scanner detail page at /scanners/[id] with full table view"
    - path: "src/components/scanners/scanner-table.tsx"
      provides: "Table component rendering data columns + AI columns per scanner type"
    - path: "src/components/scanners/scanner-header.tsx"
      provides: "Scanner header with name, type badge, description, toolbar"
    - path: "src/components/scanners/table-columns.ts"
      provides: "Column definitions per scanner type (data columns + AI column slots)"
      exports: ["getRfpColumns", "getMeetingsColumns", "getBuyersColumns"]
    - path: "src/stores/scanner-store.ts"
      provides: "Zustand store for active scanner state, scores, scoring progress"
      exports: ["useScannerStore"]
  key_links:
    - from: "src/app/(dashboard)/scanners/[id]/page.tsx"
      to: "/api/scanners/[id]"
      via: "fetch GET for scanner data with scores"
      pattern: "api/scanners"
    - from: "src/components/scanners/scanner-table.tsx"
      to: "src/stores/scanner-store.ts"
      via: "useScannerStore for scores and scoring state"
      pattern: "useScannerStore"
    - from: "src/components/scanners/scanner-table.tsx"
      to: "src/components/scanners/table-columns.ts"
      via: "Column definitions determine table structure"
      pattern: "getRfpColumns|getMeetingsColumns|getBuyersColumns"
---

<objective>
Build the scanner table view -- the core inner experience of each scanner showing entity-first data columns plus AI column placeholders in a Starbridge-style table layout.

Purpose: This is where users spend most of their time. The table view is the primary interface for analyzing scored data. It must show entity-first columns (who the buyer is), descriptive data, and AI column cells that will be filled by scoring in Plan 04.

Output: Scanner detail page at /scanners/[id] with header + toolbar + table showing data rows loaded from the appropriate data source per scanner type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-vibe-scanner/05-CONTEXT.md
@.planning/phases/05-vibe-scanner/05-01-SUMMARY.md
@.planning/phases/05-vibe-scanner/05-02-SUMMARY.md

# Key source files
@src/models/scanner.ts                    # Scanner model with types and columns (from Plan 01)
@src/lib/scanners.ts                      # Scanner CRUD (from Plan 01)
@src/models/contract.ts                  # Contract schema (data source for rfp scanners)
@src/models/signal.ts                    # Signal schema (data source for meetings scanners)
@src/models/buyer.ts                     # Buyer schema (data source for buyers scanners)
@src/lib/contracts.ts                    # Data access layer pattern
@src/app/(dashboard)/contracts/page.tsx  # Server component page pattern
@src/stores/vibe-store.ts               # Existing zustand store pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scanner store, column definitions, and scanner header</name>
  <files>src/stores/scanner-store.ts, src/components/scanners/table-columns.ts, src/components/scanners/scanner-header.tsx</files>
  <action>
**1. Create scanner zustand store** at `src/stores/scanner-store.ts`:

This replaces the old `vibe-store.ts` for the new multi-scanner architecture. Use `Record<string, ...>` patterns (not Map -- see research pitfall 6).

```typescript
interface ScoreEntry {
  score?: number;       // Optional -- some AI columns don't produce numeric scores
  response: string;     // Full AI response text
  reasoning?: string;   // Extracted reasoning for display
  isLoading?: boolean;  // True while this cell is being scored
}

// Scores indexed by: `${columnId}:${entityId}`
type ScoreKey = string;

interface ScannerStore {
  // Active scanner
  scannerId: string | null;
  scannerType: ScannerType | null;

  // Scores: key = "columnId:entityId"
  scores: Record<ScoreKey, ScoreEntry>;

  // Scoring state
  isScoring: boolean;
  scoringProgress: { scored: number; total: number; columnId?: string };

  // Threshold
  threshold: number;
  hideBelow: boolean;

  // Actions
  setActiveScanner: (id: string, type: ScannerType) => void;
  setScore: (columnId: string, entityId: string, entry: ScoreEntry) => void;
  setIsScoring: (s: boolean) => void;
  setScoringProgress: (scored: number, total: number, columnId?: string) => void;
  setThreshold: (t: number) => void;
  setHideBelow: (h: boolean) => void;
  clearScores: () => void;
  loadScores: (scores: Array<{ columnId: string; entityId: string; score?: number; response: string; reasoning?: string }>) => void;
  getScore: (columnId: string, entityId: string) => ScoreEntry | undefined;
}
```

`loadScores` converts the array into the Record with composite keys `${columnId}:${entityId}`.
`getScore` is a helper (not in store directly -- create as a standalone selector function exported alongside the store).

**2. Create column definitions** at `src/components/scanners/table-columns.ts`:

Define column configurations per scanner type. Each column has:
```typescript
interface ColumnDef {
  id: string;
  header: string;
  accessor: string;        // dot-path into the row data object (e.g., "buyerName")
  type: "text" | "number" | "date" | "badge" | "currency" | "ai";
  width?: string;          // Tailwind width class (e.g., "w-[200px]", "min-w-[150px]")
  truncate?: boolean;      // Whether to line-clamp the cell text
  aiColumnId?: string;     // Only for type: "ai" -- references scanner.aiColumns[].columnId
}
```

**RFP columns** (getRfpColumns):
1. Buyer Org Name (entity column) -- `buyerName`, type: text, w-[200px], truncate
2. Contract -- `title`, type: text, min-w-[250px], truncate (line-clamp-2)
3. Value -- `valueMax` (or valueMin), type: currency, w-[120px]
4. Deadline -- `deadlineDate`, type: date, w-[110px]
5. Sector -- `sector`, type: badge, w-[130px]
6. (AI columns appended dynamically)

**Meetings columns** (getMeetingsColumns):
1. Organization -- `organizationName`, type: text, w-[200px], truncate
2. Signal -- `title`, type: text, min-w-[250px], truncate
3. Signal Type -- `signalType`, type: badge, w-[130px]
4. Date -- `sourceDate`, type: date, w-[110px]
5. (AI columns appended dynamically)

**Buyers columns** (getBuyersColumns):
1. Organization -- `name`, type: text, w-[200px], truncate
2. Description -- `description`, type: text, min-w-[250px], truncate
3. Contacts -- `contacts.length` (computed), type: number, w-[100px]
4. Region -- `region`, type: badge, w-[130px]
5. Sector -- `sector`, type: badge, w-[130px]
6. (AI columns appended dynamically)

Export a function `getColumnsForType(type: ScannerType, aiColumns: Array<{ columnId: string; name: string }>): ColumnDef[]` that returns the data columns plus AI columns appended at the end with `type: "ai"` and `aiColumnId` set.

**3. Create ScannerHeader component** at `src/components/scanners/scanner-header.tsx`:

Client component. Props: `{ scanner: { name: string; type: ScannerType; description?: string; aiColumns: Array<{ columnId: string; name: string }> }; onAddColumn: () => void; onEditScanner: () => void; onScore: () => void; isScoring: boolean }`.

Layout:
- Top row: Scanner name as h1 + type badge next to it (colored: rfp=blue, meetings=purple, buyers=green)
- Below name: description text in text-muted-foreground (line-clamp-2)
- Toolbar row (flex, gap-2, items-center):
  - "Score All" button (primary, with Sparkles icon) -- triggers scoring. Shows "Scoring..." when isScoring
  - "Add Column" button (outline, with Plus icon) -- opens add column modal (Plan 05)
  - "Edit Scanner" button (ghost, with Pencil icon) -- future, disabled for MVP but wired
  - Separator (vertical)
  - Stats text: "X rows" (total entity count)
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify store exports useScannerStore. Verify column definitions return correct columns for each type. Verify header renders with name, type badge, and toolbar.
  </verify>
  <done>
Scanner store manages active scanner, composite-key scores, scoring progress, and threshold state. Column definitions provide entity-first layouts for all three scanner types with AI column slots. Scanner header shows name, type badge, description, and action toolbar. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scanner detail page with data-loading table</name>
  <files>src/app/(dashboard)/scanners/[id]/page.tsx, src/components/scanners/scanner-table.tsx</files>
  <action>
**1. Create ScannerTable component** at `src/components/scanners/scanner-table.tsx`:

Client component ("use client"). Props: `{ columns: ColumnDef[]; rows: Array<Record<string, unknown>>; scannerType: ScannerType }`.

Uses shadcn Table component (add via `npx shadcn@latest add table` if not present).

**Table structure:**
- `<Table>` with horizontal scroll wrapper (`overflow-x-auto`)
- `<TableHeader>` with column headers from ColumnDef
- `<TableBody>` with data rows

**Cell rendering by column type:**
- `text`: Render value as string with optional truncation (line-clamp-1 or line-clamp-2)
- `number`: Render as formatted number
- `date`: Format as "DD MMM YYYY" using Intl.DateTimeFormat
- `badge`: Render in a shadcn Badge component (variant: outline for sector, secondary for region/signal type)
- `currency`: Format using Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }). Show "--" if null/undefined.
- `ai`: AI column cell. Read score from `useScannerStore.getScore(column.aiColumnId, row._id)`:
  - If score entry exists and has numeric score: show ScoreBadge (green >= 7, yellow >= 4, red < 4)
  - If score entry exists but is text response (no numeric score): show truncated response text
  - If score entry has `isLoading: true`: show Skeleton component (animated loading)
  - If no score entry: show empty cell with light dashed border

**AI cell click handler:** When user clicks an AI cell, emit an event/callback `onAiCellClick(columnId, entityId)` that Plan 05 will wire to the side drawer. For now, just accept the callback prop and call it.

**Row styling:**
- For AI columns with numeric scores, apply threshold logic:
  - Read `threshold` and `hideBelow` from useScannerStore
  - If row's primary AI column score (first AI column) < threshold:
    - If hideBelow: hide entire row (don't render)
    - If !hideBelow: apply `opacity-40` class to the row
- Alternating row colors: even rows get subtle bg-muted/30

**Sorting:** Default sort by first AI column score descending (if scores exist), otherwise by the entity name column alphabetically. Allow column header click to toggle sort.

**Pagination:** Use simple Previous/Next pagination with 50 rows per page. Show "Showing X-Y of Z" text. Store page state locally.

**2. Create Scanner detail page** at `src/app/(dashboard)/scanners/[id]/page.tsx`:

Client component ("use client") since it manages scanner state and scoring flow.

**Data loading on mount:**
1. Extract scanner ID from URL params (await params in Next.js 16)
2. Fetch GET `/api/scanners/[id]` to load the scanner document (with scores)
3. Based on scanner.type, fetch the appropriate data source:
   - `rfp`: GET `/api/contracts` (existing endpoint -- fetch all contracts)
   - `meetings`: Fetch signals (need a GET /api/signals endpoint -- create a simple one inline or fetch directly via server action)
   - `buyers`: Fetch buyers (need a GET /api/buyers endpoint -- create a simple one inline or fetch directly via server action)
4. Load existing scores into the scanner store via `loadScores(scanner.scores)`
5. Set active scanner in store: `setActiveScanner(scanner._id, scanner.type)`
6. Generate column definitions: `getColumnsForType(scanner.type, scanner.aiColumns)`

**Note on data endpoints:** If `/api/contracts` doesn't return all contracts without pagination constraints, adjust the fetch. For signals and buyers, create minimal API routes at `src/app/api/signals/route.ts` and `src/app/api/buyers/route.ts` that return all documents with minimal fields. These are simple GET endpoints following the existing contract API pattern.

If creating these endpoint files would exceed scope, use inline server-side data fetching with `dbConnect()` + direct Mongoose queries in a useEffect. But API routes are preferred for consistency.

**Page layout (top to bottom):**
1. ScannerHeader (name, type badge, description, toolbar)
2. ScannerTable (columns + loaded data rows)

**State:**
- `scanner`: full scanner object
- `rows`: data rows from the appropriate data source
- `columns`: column definitions from getColumnsForType
- `isLoading`: initial load state

**Error handling:** Show error card if scanner not found (404) or data fetch fails.
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify page is accessible at /scanners/[id] route. Check that table renders with correct columns per scanner type. Verify AI column cells show skeleton/empty state.
  </verify>
  <done>
Scanner detail page loads scanner data and type-appropriate entity data. Table shows entity-first columns with correct formatting (text, badge, currency, date). AI column cells show scores if available or skeleton/empty state. Threshold filtering hides or dims low-scoring rows. Pagination handles large datasets. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx next build` succeeds with no errors
2. /scanners/[id] page loads and displays scanner header + table
3. RFP scanner shows Buyer Name, Contract, Value, Deadline, Sector columns
4. Meetings scanner shows Organization, Signal, Type, Date columns
5. Buyers scanner shows Organization, Description, Contacts, Region, Sector columns
6. AI column cells show empty/skeleton state when no scores exist
7. Table supports pagination (50 rows per page)
8. Column header click toggles sort
</verification>

<success_criteria>
- Each scanner type renders with its correct entity-first column layout
- Data rows load from the appropriate data source (contracts, signals, buyers)
- AI column cells are wired to the scanner store and show score/empty/loading states
- Scanner header shows name, type badge, and toolbar with Score All button
- Table handles large datasets with pagination
- VIBE-05 (score display), VIBE-07 (threshold dim/hide) partially satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-vibe-scanner/05-03-SUMMARY.md`
</output>
