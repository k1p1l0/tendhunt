---
phase: 05-vibe-scanner
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/api/vibe-scanner/score/route.ts
  - src/stores/vibe-store.ts
  - src/components/vibe-scanner/score-progress.tsx
  - src/components/vibe-scanner/scored-contract-feed.tsx
  - src/app/(dashboard)/vibe-scanner/page.tsx
  - src/components/contracts/contract-card.tsx
autonomous: true

must_haves:
  truths:
    - "AI batch-scores all contracts against the scoring prompt using Claude Haiku 4.5 with structured JSON output"
    - "User sees a progress bar updating in real-time as contracts are scored"
    - "Each contract card shows an AI score (1-10) with color-coded badge and reasoning text"
    - "User can re-score contracts after editing the prompt by clicking Apply & Score"
  artifacts:
    - path: "src/app/api/vibe-scanner/score/route.ts"
      provides: "POST SSE endpoint that batch-scores contracts via Claude Haiku with progress events"
      exports: ["POST"]
    - path: "src/stores/vibe-store.ts"
      provides: "Zustand store for scores, threshold, scoring progress, hideBelow toggle"
      exports: ["useVibeStore"]
    - path: "src/components/vibe-scanner/score-progress.tsx"
      provides: "Progress bar component showing scoring status"
    - path: "src/components/vibe-scanner/scored-contract-feed.tsx"
      provides: "Contract feed with inline scores and reasoning"
  key_links:
    - from: "src/app/(dashboard)/vibe-scanner/page.tsx"
      to: "/api/vibe-scanner/score"
      via: "fetch POST with ReadableStream reader for SSE"
      pattern: "api/vibe-scanner/score"
    - from: "src/app/api/vibe-scanner/score/route.ts"
      to: "anthropic.messages.create"
      via: "Claude Haiku API calls with prompt caching"
      pattern: "anthropic\\.messages\\.create"
    - from: "src/components/vibe-scanner/scored-contract-feed.tsx"
      to: "src/stores/vibe-store.ts"
      via: "useVibeStore hook for scores and threshold"
      pattern: "useVibeStore"
---

<objective>
Build the Claude Haiku batch scoring API with SSE streaming progress, a zustand store for client-side score state, progress bar component, and scored contract feed display.

Purpose: This is the core AI scoring engine -- the primary differentiator of TendHunt. Users trigger scoring and watch contracts get scored in real-time, then see results on each contract card.

Output: Working batch scoring flow from button click through AI scoring to displayed results with progress feedback.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-vibe-scanner/05-RESEARCH.md
@.planning/phases/05-vibe-scanner/05-01-SUMMARY.md

# Key source files
@src/models/vibe-scanner.ts              # VibeScanner model (from Plan 01)
@src/lib/vibe-scanner.ts                 # Prompt generation + scanner CRUD (from Plan 01)
@src/lib/anthropic.ts                    # Anthropic client singleton
@src/models/contract.ts                  # Contract schema with vibeScore placeholder
@src/lib/contracts.ts                    # fetchContracts() data access
@src/components/contracts/contract-card.tsx  # Existing card with ScoreBadge
@src/app/(dashboard)/vibe-scanner/page.tsx  # Vibe Scanner page (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Zustand store and batch scoring SSE API endpoint</name>
  <files>src/stores/vibe-store.ts, src/app/api/vibe-scanner/score/route.ts</files>
  <action>
**1. Install p-limit** -- Run `npm install p-limit`.

**2. Add shadcn Progress component** -- Run `npx shadcn@latest add progress` (if not already present).

**3. Create zustand store** at `src/stores/vibe-store.ts`:

Use `Record<string, { score: number; reasoning: string }>` NOT Map (Map doesn't serialize -- see Pitfall 6 in research).

```typescript
interface VibeStore {
  scores: Record<string, { score: number; reasoning: string }>;
  threshold: number;
  hideBelow: boolean;
  isScoring: boolean;
  scoringProgress: { scored: number; total: number };
  setScore: (contractId: string, score: number, reasoning: string) => void;
  setThreshold: (t: number) => void;
  setHideBelow: (h: boolean) => void;
  setIsScoring: (s: boolean) => void;
  setScoringProgress: (scored: number, total: number) => void;
  clearScores: () => void;
  loadScores: (scores: Array<{ contractId: string; score: number; reasoning: string }>) => void;
}
```

`loadScores` takes an array (from API response when loading existing scanner) and populates the Record. `clearScores` resets to empty `{}`. `setScore` adds one entry (called during SSE progress).

**4. Create batch scoring SSE endpoint** at `src/app/api/vibe-scanner/score/route.ts`:

POST handler that returns an SSE stream:

- `auth()` for userId, return 401 if not authenticated
- Parse body: `{ scannerId: string }` -- validate scannerId exists
- `dbConnect()`, load VibeScanner by `_id` and verify it belongs to userId
- Load all contracts with minimal fields: `Contract.find({}).select('title description buyerName sector valueMin valueMax buyerRegion cpvCodes').lean()`
- Truncate each contract description to 2000 characters (see Research pitfall 3)
- Clear existing contractScores on the scanner document (to avoid stale scores after re-scoring -- see Pitfall 4)
- Create SSE ReadableStream:

```typescript
const encoder = new TextEncoder();
const stream = new ReadableStream({
  async start(controller) {
    const pLimit = (await import('p-limit')).default;
    const limit = pLimit(5); // 5 concurrent API calls

    // Send initial event
    controller.enqueue(encoder.encode(
      `data: ${JSON.stringify({ type: 'start', total: contracts.length })}\n\n`
    ));

    let scored = 0;
    const allScores: Array<{ contractId: string; score: number; reasoning: string }> = [];

    // Process all contracts with concurrency limit
    const promises = contracts.map(contract => limit(async () => {
      try {
        const result = await scoreOneContract(contract, scanner.scoringPrompt);
        scored++;
        allScores.push({ contractId: String(contract._id), ...result });
        controller.enqueue(encoder.encode(
          `data: ${JSON.stringify({ type: 'progress', scored, total: contracts.length, contractId: String(contract._id), score: result.score, reasoning: result.reasoning })}\n\n`
        ));
      } catch (err) {
        scored++;
        // Score as 0 on error, don't block other contracts
        allScores.push({ contractId: String(contract._id), score: 0, reasoning: 'Scoring failed' });
        controller.enqueue(encoder.encode(
          `data: ${JSON.stringify({ type: 'progress', scored, total: contracts.length, contractId: String(contract._id), score: 0, reasoning: 'Scoring failed' })}\n\n`
        ));
      }
    }));

    await Promise.all(promises);

    // Persist all scores to MongoDB
    await VibeScanner.updateOne(
      { _id: scanner._id },
      {
        $set: {
          contractScores: allScores.map(s => ({ contractId: s.contractId, score: s.score, reasoning: s.reasoning })),
          lastScoredAt: new Date()
        }
      }
    );

    // Also update the Contract documents with the latest scores for dashboard display
    const bulkOps = allScores.filter(s => s.score > 0).map(s => ({
      updateOne: {
        filter: { _id: s.contractId },
        update: { $set: { vibeScore: s.score, vibeReasoning: s.reasoning } }
      }
    }));
    if (bulkOps.length > 0) {
      await Contract.bulkWrite(bulkOps);
    }

    controller.enqueue(encoder.encode(
      `data: ${JSON.stringify({ type: 'complete', scored })}\n\n`
    ));
    controller.close();
  }
});
```

Return `new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' } })`.

**scoreOneContract helper function** (in the same file or in vibe-scanner lib):

```typescript
async function scoreOneContract(contract: any, scoringPrompt: string) {
  const response = await anthropic.messages.create({
    model: "claude-haiku-4-5-20251001",
    max_tokens: 256,
    system: [
      {
        type: "text",
        text: scoringPrompt,
        cache_control: { type: "ephemeral" }  // Prompt caching -- 5 min TTL
      }
    ],
    messages: [
      {
        role: "user",
        content: `Score this contract:\n\nTitle: ${contract.title}\nBuyer: ${contract.buyerName}\nDescription: ${(contract.description || '').substring(0, 2000)}\nSector: ${contract.sector || 'Unknown'}\nRegion: ${contract.buyerRegion || 'Unknown'}\nValue: ${contract.valueMin || 'N/A'}-${contract.valueMax || 'N/A'} GBP\nCPV Codes: ${(contract.cpvCodes || []).join(', ') || 'None'}`
      }
    ],
    output_config: {
      format: {
        type: "json_schema" as const,
        schema: {
          type: "object" as const,
          properties: {
            score: { type: "number" as const },
            reasoning: { type: "string" as const }
          },
          required: ["score", "reasoning"],
          additionalProperties: false
        }
      }
    }
  });

  const content = response.content[0];
  if (content.type === 'text') {
    return JSON.parse(content.text) as { score: number; reasoning: string };
  }
  return { score: 0, reasoning: 'Failed to parse response' };
}
```

IMPORTANT: Use `cache_control: { type: "ephemeral" }` on the system message for prompt caching. The scoring prompt must be >4096 tokens for Haiku 4.5 caching to work (ensured by Plan 01's prompt generation). Do NOT add any beta headers -- prompt caching and structured output are both GA.
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Check that p-limit is in package.json. Verify the store exports useVibeStore.
  </verify>
  <done>
Zustand store manages scores, progress, threshold, and hideBelow state with Record-based score storage. SSE scoring endpoint uses p-limit(5) concurrency, prompt caching, structured JSON output, persists scores to both VibeScanner and Contract documents, and streams progress events. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Progress bar, scored contract feed, and page integration</name>
  <files>src/components/vibe-scanner/score-progress.tsx, src/components/vibe-scanner/scored-contract-feed.tsx, src/app/(dashboard)/vibe-scanner/page.tsx, src/components/contracts/contract-card.tsx</files>
  <action>
**1. Create ScoreProgress component** at `src/components/vibe-scanner/score-progress.tsx`:

Client component. Uses `useVibeStore` to read `isScoring`, `scoringProgress`. Displays:
- shadcn `Progress` component with value = `(scored / total) * 100`
- Text: "Scoring X of Y contracts..." (or "Scoring complete!" when done)
- Only visible when `isScoring` is true or `scoringProgress.total > 0`
- Smooth animation on the progress bar

**2. Create ScoredContractFeed component** at `src/components/vibe-scanner/scored-contract-feed.tsx`:

Client component that fetches and displays contracts with their vibe scores overlaid.

Props: none (reads from useVibeStore).

On mount, fetch contracts from GET `/api/vibe-scanner` to load existing scores into the store (if scanner has contractScores). Also fetch contracts data (can reuse a simplified fetch or load from the scanner's scores).

Display:
- List of contract cards (use a simplified inline card, not the full ContractCard link component -- since we're on the vibe-scanner page, not the contracts feed)
- Each card shows: title (line-clamp-1), buyer name, score badge (color-coded: green >= 7, yellow >= 4, red < 4), and reasoning text (line-clamp-2, text-sm, text-muted-foreground)
- Cards sorted by score descending
- If no scores exist, show empty state: "No contracts scored yet. Click 'Apply & Score' to begin."

**3. Update ContractCard** at `src/components/contracts/contract-card.tsx`:

Add an optional `vibeReasoning?: string | null` prop to `ContractCardData`. When vibeScore exists and reasoning is provided, show a tooltip or small text snippet under the score badge. Keep this minimal -- just add the prop threading; the main scored display is on the Vibe Scanner page.

**4. Update Vibe Scanner page** at `src/app/(dashboard)/vibe-scanner/page.tsx`:

Integrate the scoring flow:

- Import `useVibeStore` for state management
- Add `startScoring()` function that:
  1. If prompt changed, PATCH `/api/vibe-scanner` with updated prompt
  2. Clear existing scores in store (`clearScores()`)
  3. Set `isScoring(true)`
  4. POST to `/api/vibe-scanner/score` with `{ scannerId: scanner._id }`
  5. Read the SSE stream using fetch + ReadableStream reader (NOT EventSource -- it doesn't support POST, see Pitfall 5):
     ```typescript
     const reader = response.body!.getReader();
     const decoder = new TextDecoder();
     let buffer = '';
     while (true) {
       const { done, value } = await reader.read();
       if (done) break;
       buffer += decoder.decode(value, { stream: true });
       const lines = buffer.split('\n\n');
       buffer = lines.pop() || '';
       for (const line of lines) {
         if (line.startsWith('data: ')) {
           const data = JSON.parse(line.slice(6));
           if (data.type === 'start') setScoringProgress(0, data.total);
           if (data.type === 'progress') {
             setScoringProgress(data.scored, data.total);
             setScore(data.contractId, data.score, data.reasoning);
           }
           if (data.type === 'complete') setIsScoring(false);
         }
       }
     }
     ```
  6. Set `isScoring(false)` when stream ends

- On initial page load, if scanner has existing contractScores, load them into the zustand store via `loadScores()`

- Layout (top to bottom):
  1. Page header (title + subtitle)
  2. PromptEditor (with onApplyScore wired to startScoring)
  3. ScoreProgress (visible during scoring)
  4. ScoredContractFeed (shows scored contracts)
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify all component files exist. Check that the page correctly wires prompt editor -> scoring API -> progress bar -> scored feed.
  </verify>
  <done>
Progress bar shows real-time scoring status from SSE events. Scored contract feed displays contracts with color-coded score badges and reasoning text, sorted by score. Vibe Scanner page integrates the full flow: edit prompt -> Apply & Score -> see progress -> view results. Re-scoring clears old scores first. Existing scores load on page mount. VIBE-04, VIBE-05, VIBE-09, VIBE-10 requirements satisfied. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx next build` succeeds with no errors
2. p-limit installed in package.json
3. SSE endpoint streams progress events as contracts are scored
4. Zustand store correctly tracks scores, progress, and threshold state
5. Progress bar updates in real-time during scoring
6. Scored contracts display with color-coded badges and reasoning
7. Re-scoring clears old scores and starts fresh
</verification>

<success_criteria>
- Clicking "Apply & Score" triggers batch scoring of all contracts via Claude Haiku 4.5
- Progress bar shows real-time progress (X of Y contracts scored)
- Each scored contract shows a score (1-10) with color-coded badge and reasoning text
- User can edit the prompt and re-score to get different results
- Scores persist in MongoDB (VibeScanner.contractScores + Contract.vibeScore)
- VIBE-04, VIBE-05, VIBE-09, VIBE-10 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-vibe-scanner/05-02-SUMMARY.md`
</output>
