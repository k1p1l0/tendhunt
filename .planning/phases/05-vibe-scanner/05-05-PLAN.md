---
phase: 05-vibe-scanner
plan: 05
type: execute
wave: 4
depends_on: ["05-03", "05-04"]
files_modified:
  - src/components/scanners/add-column-modal.tsx
  - src/components/scanners/scanner-table.tsx
  - src/app/(dashboard)/scanners/[id]/page.tsx
  - src/app/api/scanners/[id]/columns/route.ts
  - src/app/api/scanners/[id]/score-column/route.ts
autonomous: true

must_haves:
  truths:
    - "User can click 'Add Column' to open a modal with Column Name and Prompt textarea"
    - "Adding a new AI column immediately auto-scores all existing rows"
    - "AI column cells in the table show per-cell loading states during scoring"
    - "Scored AI cells display color-coded scores or text responses"
    - "User can click an AI cell to see the full response in a side drawer"
    - "Score All button in header triggers scoring for all columns"
  artifacts:
    - path: "src/components/scanners/add-column-modal.tsx"
      provides: "Modal for adding custom AI columns with name + prompt"
    - path: "src/app/api/scanners/[id]/columns/route.ts"
      provides: "POST endpoint to add a new AI column to a scanner"
      exports: ["POST"]
    - path: "src/app/api/scanners/[id]/score-column/route.ts"
      provides: "POST SSE endpoint to score a single column for all entities"
      exports: ["POST"]
  key_links:
    - from: "src/components/scanners/add-column-modal.tsx"
      to: "/api/scanners/[id]/columns"
      via: "POST to add column, then auto-trigger scoring"
      pattern: "api/scanners.*columns"
    - from: "src/app/(dashboard)/scanners/[id]/page.tsx"
      to: "/api/scanners/[id]/score"
      via: "fetch POST with SSE reader for full scoring"
      pattern: "api/scanners.*score"
    - from: "src/app/(dashboard)/scanners/[id]/page.tsx"
      to: "/api/scanners/[id]/score-column"
      via: "fetch POST with SSE reader for single column scoring"
      pattern: "api/scanners.*score-column"
---

<objective>
Add custom AI column creation, wire scoring into the table view with per-cell loading states, and implement the full Score All flow from the scanner header.

Purpose: Custom AI columns are a core differentiator for the investor demo. Users must be able to add their own analysis columns and see results populate the table in real-time. This plan connects the scoring engine (Plan 04) to the table UI (Plan 03).

Output: Add Column modal, per-cell scoring integration in table, Score All button wired to SSE, and single-column scoring endpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-vibe-scanner/05-CONTEXT.md
@.planning/phases/05-vibe-scanner/05-01-SUMMARY.md
@.planning/phases/05-vibe-scanner/05-03-SUMMARY.md
@.planning/phases/05-vibe-scanner/05-04-SUMMARY.md

# Key source files
@src/models/scanner.ts                         # Scanner model (from Plan 01)
@src/lib/scanners.ts                           # addAiColumn (from Plan 01)
@src/lib/scoring-engine.ts                     # Scoring engine (from Plan 04)
@src/app/api/scanners/[id]/score/route.ts      # Full scoring SSE (from Plan 04)
@src/stores/scanner-store.ts                   # Scanner store (from Plan 03)
@src/components/scanners/scanner-table.tsx      # Table component (from Plan 03)
@src/components/scanners/scanner-header.tsx     # Header with Score All button (from Plan 03)
@src/app/(dashboard)/scanners/[id]/page.tsx    # Scanner detail page (from Plan 03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Column modal and column API endpoint</name>
  <files>src/components/scanners/add-column-modal.tsx, src/app/api/scanners/[id]/columns/route.ts</files>
  <action>
**1. Create AddColumnModal component** at `src/components/scanners/add-column-modal.tsx`:

Client component ("use client"). Props: `{ open: boolean; onOpenChange: (open: boolean) => void; scannerId: string; onColumnAdded: (column: { columnId: string; name: string; prompt: string }) => void }`.

Uses shadcn Dialog. Layout:
- Dialog title: "Add AI Column"
- Dialog description: "Define a custom analysis column. The AI will evaluate every row using your prompt."
- **Column Name** input (Input component): placeholder "e.g., Contract Risk Assessment"
- **Prompt** textarea (Textarea component, min-height 150px, font-mono): placeholder "Describe what you want the AI to analyze for each row..."
- Helper text below prompt: "Tip: Reference row data like the contract title, buyer name, or sector in your prompt for more targeted analysis."
- Bottom actions: "Cancel" (outline) and "Add & Score" (primary)

**On "Add & Score" click:**
1. Validate name and prompt are non-empty
2. POST to `/api/scanners/[scannerId]/columns` with `{ name, prompt }`
3. On success, call `onColumnAdded` with the returned column data
4. Close the dialog
5. The parent page will then trigger single-column scoring (see Task 2)

State: `name`, `prompt`, `isSubmitting`, `error`.

**2. Create column API endpoint** at `src/app/api/scanners/[id]/columns/route.ts`:

POST handler:
- auth() for userId, 401 if not authenticated
- Extract scanner id from params (await params)
- Parse body: `{ name: string, prompt: string }`
- Validate name and prompt are non-empty strings
- Call `addAiColumn(id, userId, { name, prompt })` from scanners library
- Return `{ column: newColumn }` with the newly added column data (columnId, name, prompt)
- Return 404 if scanner not found
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify the modal renders with name input and prompt textarea. Verify the API endpoint creates a new column.
  </verify>
  <done>
Add Column modal lets users define custom AI columns with a name and prompt. API endpoint persists the new column to the scanner's aiColumns array with a nanoid-generated columnId. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire scoring flow into scanner page with SSE client and per-cell loading</name>
  <files>src/app/(dashboard)/scanners/[id]/page.tsx, src/components/scanners/scanner-table.tsx, src/app/api/scanners/[id]/score-column/route.ts</files>
  <action>
**1. Create single-column scoring endpoint** at `src/app/api/scanners/[id]/score-column/route.ts`:

POST handler that scores only ONE AI column for all entities. Used when adding a new column.

- auth() for userId, 401 if not authenticated
- Extract scanner id from params
- Parse body: `{ columnId: string }`
- Load scanner and verify ownership
- Find the column definition in scanner.aiColumns by columnId
- Load entities based on scanner type (same as full score endpoint)
- Remove existing scores for this columnId: filter out from scanner.scores
- Use the scoring engine's scoreOneEntity in a p-limit(5) loop
- Stream SSE events like the full score endpoint but only for one column
- After scoring, push new scores to scanner.scores via $push or re-set the full array
- Return SSE stream

This is similar to the full score endpoint but scoped to a single column. Import scoreOneEntity and buildScoringSystemPrompt from scoring-engine.ts.

**2. Update scanner detail page** at `src/app/(dashboard)/scanners/[id]/page.tsx`:

Add scoring integration:

**Score All flow (from header "Score All" button):**
- Call `clearScores()` on scanner store
- Set all AI cells to loading state
- POST to `/api/scanners/[id]/score` (full scoring endpoint from Plan 04)
- Read SSE stream using fetch + ReadableStream reader:
  ```typescript
  const reader = response.body!.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split("\n\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      if (line.startsWith("data: ")) {
        const event = JSON.parse(line.slice(6));
        if (event.type === "column_start") {
          setScoringProgress(0, event.total, event.columnId);
        }
        if (event.type === "progress") {
          setScoringProgress(event.scored, event.total, event.columnId);
          setScore(event.columnId, event.entityId, {
            score: event.score,
            response: event.response,
            reasoning: event.reasoning,
          });
        }
        if (event.type === "complete") {
          setIsScoring(false);
        }
      }
    }
  }
  ```

**Add Column flow (from header "Add Column" button):**
- Open AddColumnModal
- When column is added (onColumnAdded):
  1. Refresh scanner data to get updated aiColumns
  2. Update column definitions via getColumnsForType
  3. Trigger single-column scoring: POST `/api/scanners/[id]/score-column` with `{ columnId }`
  4. Read SSE stream same as Score All but scoped to new column
  5. Table shows loading skeletons in the new column's cells as they get scored

**3. Update ScannerTable** at `src/components/scanners/scanner-table.tsx`:

Ensure AI cells properly read from scanner store:
- For each AI column cell, read `scores[${columnId}:${entityId}]` from store
- If entry has `isLoading: true`: show Skeleton (animated shimmer)
- If entry has numeric score: show ScoreBadge (green/yellow/red)
- If entry has text response but no score: show truncated text
- If no entry: show subtle "--" or empty with dashed border

Before scoring starts, set all AI cells to `isLoading: true` in the store. The page should pre-populate loading state:
```typescript
// Before starting SSE
for (const column of scanner.aiColumns) {
  for (const row of rows) {
    setScore(column.columnId, String(row._id), { isLoading: true, response: "", reasoning: "" });
  }
}
```

**AI cell click handler:** Wire `onAiCellClick` to store the clicked cell info (columnId, entityId) in local state. Plan 06 will add the side drawer. For now, clicking an AI cell could show a toast or popover with the full reasoning as a temporary UX.
  </action>
  <verify>
Run `npx next build` to verify no TypeScript errors. Verify Score All triggers SSE and updates table cells. Verify Add Column creates a new column and auto-scores it. Verify per-cell loading states display correctly.
  </verify>
  <done>
Score All button triggers full batch scoring across all AI columns with SSE progress. Add Column modal creates a new AI column and immediately scores all rows for it. Table cells show loading skeletons during scoring and color-coded results when complete. Single-column scoring endpoint enables efficient re-scoring of individual columns. VIBE-04 (batch scoring), VIBE-09 (re-scoring), VIBE-10 (progress) requirements satisfied. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npx next build` succeeds with no errors
2. Add Column modal opens from header toolbar
3. Custom column is created with name and prompt
4. New column auto-scores all rows with SSE progress
5. Score All scores all columns for all entities
6. Table AI cells show loading -> scored states
7. Per-cell loading skeletons animate during scoring
8. Scored cells display color-coded badges or text responses
</verification>

<success_criteria>
- Users can add custom AI columns with any prompt
- Adding a column immediately triggers scoring for all rows
- Score All button scores all AI columns across all entities
- SSE streams per-entity progress for real-time table updates
- AI cells transition from loading skeleton to scored state
- Custom AI columns are a visible differentiator for investor demo
- VIBE-04, VIBE-09, VIBE-10 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-vibe-scanner/05-05-SUMMARY.md`
</output>
