---
phase: 19-research-agent-chat-panel
plan: 03
type: execute
wave: 2
depends_on: ["19-01", "19-02"]
files_modified:
  - apps/web/src/hooks/use-agent.ts
  - apps/web/src/components/agent/agent-panel.tsx
  - apps/web/src/components/agent/agent-message-list.tsx
  - apps/web/src/components/agent/agent-input.tsx
  - apps/web/src/components/agent/suggested-actions.tsx
  - apps/web/src/app/(dashboard)/scanners/[id]/page.tsx
  - apps/web/src/app/(dashboard)/buyers/[id]/page.tsx
  - apps/web/src/app/(dashboard)/contracts/[id]/page.tsx
  - apps/web/src/app/(dashboard)/page.tsx
  - apps/web/src/app/api/agent/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "User can send a message and see a real streamed agent response from Claude Sonnet"
    - "Tool calls appear as indicators during response streaming, showing tool name and result summary"
    - "Agent knows the current page context when answering questions"
    - "Suggested prompts reference the current entity name when on buyer/contract/scanner pages"
    - "Conversations persist to MongoDB and survive panel close/reopen within session"
  artifacts:
    - path: "apps/web/src/hooks/use-agent.ts"
      provides: "Custom hook for sending messages, streaming SSE, managing conversation lifecycle"
      exports: ["useAgent"]
  key_links:
    - from: "apps/web/src/hooks/use-agent.ts"
      to: "apps/web/src/app/api/agent/chat/route.ts"
      via: "fetch POST with SSE stream reading"
      pattern: "fetch.*api/agent/chat"
    - from: "apps/web/src/hooks/use-agent.ts"
      to: "apps/web/src/stores/agent-store.ts"
      via: "addMessage, updateMessage, setIsStreaming"
      pattern: "useAgentStore"
    - from: "apps/web/src/hooks/use-agent.ts"
      to: "apps/web/src/components/agent/agent-provider.tsx"
      via: "useAgentContext for current page context"
      pattern: "useAgentContext"
    - from: "apps/web/src/app/(dashboard)/scanners/[id]/page.tsx"
      to: "apps/web/src/components/agent/agent-provider.tsx"
      via: "useAgentContext().setContext on mount"
      pattern: "setContext"
---

<objective>
Wire the frontend UI to the backend API: build the SSE streaming hook, connect message sending, add page-level context setting, and enable conversation persistence.

Purpose: This plan connects Plans 01 and 02, making the agent fully functional -- users can ask questions and get real AI responses with tool call indicators.
Output: Working end-to-end agent chat with streaming responses, tool indicators, context awareness, and persistence.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/output.md — SSE event types, context shape, FR-02 (context awareness), FR-05 (tool indicators)
@.planning/phases/19-research-agent-chat-panel/19-RESEARCH.md — SSE client reader pattern, context setting pattern
@.planning/phases/19-research-agent-chat-panel/19-01-SUMMARY.md
@.planning/phases/19-research-agent-chat-panel/19-02-SUMMARY.md

Key existing files to reference:
@apps/web/src/app/(dashboard)/scanners/[id]/page.tsx — SSE reader pattern (readSSEStream), context for scanner page
@apps/web/src/app/(dashboard)/buyers/[id]/page.tsx — Buyer detail page for context setting
@apps/web/src/app/(dashboard)/contracts/[id]/page.tsx — Contract detail page for context setting
</context>

<tasks>

<task type="auto">
  <name>Task 1: useAgent hook — SSE streaming client, message lifecycle, abort controller</name>
  <files>
    apps/web/src/hooks/use-agent.ts
    apps/web/src/components/agent/agent-panel.tsx
    apps/web/src/components/agent/agent-message-list.tsx
    apps/web/src/components/agent/agent-input.tsx
    apps/web/src/components/agent/suggested-actions.tsx
  </files>
  <action>
    **useAgent hook (`apps/web/src/hooks/use-agent.ts`):**
    "use client" hook that manages the full chat lifecycle. Returns:
    ```typescript
    interface UseAgentReturn {
      sendMessage: (content: string) => Promise<void>;
      stopStreaming: () => void;
      isStreaming: boolean;
      messages: AgentMessage[];
      startNewConversation: () => void;
    }
    ```

    Implementation:
    1. Read agent context from `useAgentContext()` hook.
    2. Read/write conversation state from `useAgentStore`.
    3. Keep an `AbortController` ref for stream cancellation.

    **sendMessage(content: string):**
    ```
    - If isStreaming, return early (prevent double-send)
    - If no active conversation, create one (nanoid ID, title = first 50 chars of content)
    - Add user message to store: { id: nanoid(), role: "user", content, timestamp: new Date() }
    - Add placeholder assistant message: { id: nanoid(), role: "assistant", content: "", toolCalls: [], timestamp: new Date() }
    - Set isStreaming = true
    - Create new AbortController, store in ref
    - Build messages array from store (map to { role, content } format, exclude empty placeholder)
    - POST to /api/agent/chat with { messages, context, conversationId }
    - Read SSE stream using the same readSSEStream pattern from scanner page:
      ```
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const event = JSON.parse(line.slice(6));
            handleSSEEvent(event, assistantMessageId);
          }
        }
      }
      ```
    - On stream complete: set isStreaming = false
    - On error: set isStreaming = false, update assistant message with error text
    - On abort: set isStreaming = false
    ```

    **handleSSEEvent(event, messageId):**
    ```
    switch (event.type):
      case "text_delta":
        - Append event.content to the assistant message's content via updateMessage
      case "tool_call_start":
        - Add tool call entry to assistant message's toolCalls array: { toolName: event.toolName, args: event.args, isLoading: true }
      case "tool_call_result":
        - Update the matching tool call: set isLoading = false, summary = event.summary, result = event.summary
        - If event.action exists, handle action (for create_scanner: use router.push; for others: show user-friendly message)
      case "done":
        - Set isStreaming = false
        - Fire-and-forget save conversation to MongoDB (POST to a new /api/agent/conversations endpoint or inline in chat route)
      case "error":
        - Set isStreaming = false
        - Append error text to assistant message
    ```

    **stopStreaming():**
    - Call `abortControllerRef.current?.abort()`
    - Set isStreaming = false

    **startNewConversation():**
    - Create new conversation in store with nanoid ID
    - Set as active conversation

    **Wire hook into panel components:**

    Update `agent-panel.tsx`:
    - Call `const { sendMessage, stopStreaming, isStreaming, messages, startNewConversation } = useAgent();`
    - Pass `sendMessage` as `onSend` to AgentInput.
    - Pass `stopStreaming` as `onStop` to AgentInput.
    - Pass `startNewConversation` to AgentPanelHeader's "New Chat" button.
    - Pass `messages` to AgentMessageList.

    Update `agent-message-list.tsx`:
    - Accept `messages` as prop instead of reading from store directly.
    - Accept `onSend` prop to pass to SuggestedActions.

    Update `agent-input.tsx`:
    - Accept `onSend`, `onStop`, `isStreaming` as props.
    - Clear textarea after sending.
    - Disable textarea when isStreaming.
    - Show stop button (Square icon) when isStreaming, send button (ArrowUp) when not.

    Update `suggested-actions.tsx`:
    - Accept `onSend` callback prop.
    - When a prompt is clicked, call `onSend(promptText)`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - useAgent hook exports sendMessage, stopStreaming, isStreaming, messages, startNewConversation
    - Sending a message creates both user and assistant message entries in the store
    - SSE events are parsed and dispatched correctly (text_delta appends, tool_call_start/result update toolCalls)
    - Stop button aborts the stream
  </verify>
  <done>
    Full chat lifecycle works: user sends message, SSE stream starts, text deltas and tool calls stream into the UI, stop button cancels, new conversation resets state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Page context setters + conversation persistence + API save endpoint</name>
  <files>
    apps/web/src/app/(dashboard)/scanners/[id]/page.tsx
    apps/web/src/app/(dashboard)/buyers/[id]/page.tsx
    apps/web/src/app/(dashboard)/contracts/[id]/page.tsx
    apps/web/src/app/(dashboard)/page.tsx
    apps/web/src/app/api/agent/chat/route.ts
  </files>
  <action>
    **Page context setters:**

    Add `useAgentContext().setContext(...)` calls to each page. Each page sets context on mount and clears on unmount.

    **Scanner page (`apps/web/src/app/(dashboard)/scanners/[id]/page.tsx`):**
    Find the client component that has access to scanner data (ScannerPageContent or similar). Add:
    ```tsx
    const { setContext } = useAgentContext();
    useEffect(() => {
      if (scanner) {
        setContext({
          page: "scanner",
          scannerId: scanner._id.toString(),
          scannerType: scanner.type,
          scannerName: scanner.name,
          scannerQuery: scanner.searchQuery,
        });
      }
      return () => setContext({ page: "dashboard" });
    }, [scanner?._id, scanner?.name, scanner?.type, scanner?.searchQuery]);
    ```
    Also pass `selectedRow` context when a row is selected in the grid (if there's a row selection handler, update the context).

    **Buyer detail page (`apps/web/src/app/(dashboard)/buyers/[id]/page.tsx`):**
    Find the client component. Add:
    ```tsx
    const { setContext } = useAgentContext();
    useEffect(() => {
      if (buyer) {
        setContext({
          page: "buyer_detail",
          buyerId: buyer._id.toString(),
          buyerName: buyer.name,
          buyerSector: buyer.sector,
          buyerRegion: buyer.region,
          buyerOrgType: buyer.orgType,
        });
      }
      return () => setContext({ page: "dashboard" });
    }, [buyer?._id]);
    ```

    **Contract detail page (`apps/web/src/app/(dashboard)/contracts/[id]/page.tsx`):**
    Find the client component. Add:
    ```tsx
    const { setContext } = useAgentContext();
    useEffect(() => {
      if (contract) {
        setContext({
          page: "contract_detail",
          contractId: contract._id.toString(),
          contractTitle: contract.title,
          contractBuyerName: contract.buyerName,
          contractSector: contract.sector,
          contractValue: contract.valueMax ? `GBP ${contract.valueMax.toLocaleString()}` : undefined,
        });
      }
      return () => setContext({ page: "dashboard" });
    }, [contract?._id]);
    ```

    **Dashboard page (`apps/web/src/app/(dashboard)/page.tsx`):**
    Find or create a client wrapper. Add:
    ```tsx
    const { setContext } = useAgentContext();
    useEffect(() => {
      setContext({ page: "dashboard" });
    }, []);
    ```

    NOTE: Some of these pages are server components. If the page.tsx is a server component, you CANNOT use hooks there. Instead, find the nearest client component child (e.g., BuyerDetailClient, ScannerPageContent) and add the context setter there. If no suitable client component exists, create a minimal `AgentContextSetter` client component that takes the entity data as props and calls `setContext` in a useEffect.

    **Conversation persistence in API route:**

    Update `apps/web/src/app/api/agent/chat/route.ts`:
    After the tool loop completes (before sending `done` event), save/update the conversation:
    ```typescript
    // Collect the final assistant text from all text_delta events
    // Save conversation to MongoDB
    if (conversationId) {
      await ChatConversation.findOneAndUpdate(
        { _id: conversationId, userId },
        {
          $push: {
            messages: {
              $each: [
                // The user message that was sent
                { role: "user", content: messages[messages.length - 1]?.content || "", timestamp: new Date() },
                // The assistant response (accumulated text + tool call summaries)
                { role: "assistant", content: assistantText, toolCalls: toolCallSummaries, timestamp: new Date() },
              ],
            },
          },
          $set: { lastMessageAt: new Date() },
        },
        { upsert: true, new: true }
      );
    } else {
      // Create new conversation
      const conv = await ChatConversation.create({
        userId,
        title: (messages[messages.length - 1]?.content || "New conversation").slice(0, 50),
        context,
        messages: [
          { role: "user", content: messages[messages.length - 1]?.content || "", timestamp: new Date() },
          { role: "assistant", content: assistantText, toolCalls: toolCallSummaries, timestamp: new Date() },
        ],
        lastMessageAt: new Date(),
      });
      // Send conversation ID back to client
      send({ type: "conversation_id", id: conv._id.toString() });
    }
    ```

    Track `assistantText` by accumulating text blocks during the loop. Track `toolCallSummaries` by collecting { toolName, summary } for each tool call.

    Update the useAgent hook to listen for `conversation_id` events and store the ID.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - Opening the agent on a scanner page → suggested prompts reference scanner type
    - Opening the agent on a buyer detail page → suggested prompts reference buyer name
    - Opening the agent on dashboard → shows generic prompts
    - After sending a message, a ChatConversation document exists in MongoDB
    - Closing and reopening the panel preserves the conversation within the session
  </verify>
  <done>
    Agent is context-aware on all pages. Conversations persist to MongoDB. Suggested prompts dynamically reflect current entity.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with no errors
2. Full round-trip works: type message -> stream response -> see text + tool indicators -> response complete
3. Agent knows scanner name/type when opened on scanner page
4. Agent knows buyer name when opened on buyer detail page
5. Tool call indicators show "Searching..." then "Found N matches"
6. Stop button cancels mid-stream
7. New Chat button resets conversation
8. Conversation saved to MongoDB after each exchange
</verification>

<success_criteria>
- User can send a message and receive a streamed response from Claude Sonnet
- Tool calls display with loading state then result summary
- Context is set correctly per page (scanner, buyer, contract, dashboard)
- Suggested prompts are page/entity-aware
- Conversations persist to MongoDB
- Stop button cancels streaming
</success_criteria>

<output>
After completion, create `.planning/phases/19-research-agent-chat-panel/19-03-SUMMARY.md`
</output>
