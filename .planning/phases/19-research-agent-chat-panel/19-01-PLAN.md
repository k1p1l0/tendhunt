---
phase: 19-research-agent-chat-panel
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/models/chat-conversation.ts
  - apps/web/src/lib/agent/system-prompt.ts
  - apps/web/src/lib/agent/tools.ts
  - apps/web/src/lib/agent/tool-handlers.ts
  - apps/web/src/app/api/agent/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/agent/chat returns a valid SSE stream with text_delta, tool_call_start, tool_call_result, and done events"
    - "Agent tools query real MongoDB data via existing fetchBuyers, fetchContracts, and other query functions"
    - "ChatConversation model persists conversation messages to MongoDB"
    - "System prompt includes current page context and company profile"
    - "Tool loop runs max 5 iterations to prevent infinite loops"
  artifacts:
    - path: "apps/web/src/models/chat-conversation.ts"
      provides: "MongoDB model for persisting agent conversations"
      contains: "ChatConversation"
    - path: "apps/web/src/lib/agent/system-prompt.ts"
      provides: "System prompt builder with context injection"
      exports: ["buildSystemPrompt"]
    - path: "apps/web/src/lib/agent/tools.ts"
      provides: "Anthropic tool definitions array"
      exports: ["getToolDefinitions"]
    - path: "apps/web/src/lib/agent/tool-handlers.ts"
      provides: "Server-side tool execution handlers"
      exports: ["executeToolHandler"]
    - path: "apps/web/src/app/api/agent/chat/route.ts"
      provides: "SSE streaming POST endpoint for agent chat"
      exports: ["POST"]
  key_links:
    - from: "apps/web/src/app/api/agent/chat/route.ts"
      to: "apps/web/src/lib/agent/tools.ts"
      via: "getToolDefinitions() import"
      pattern: "getToolDefinitions"
    - from: "apps/web/src/app/api/agent/chat/route.ts"
      to: "apps/web/src/lib/agent/tool-handlers.ts"
      via: "executeToolHandler() call in tool loop"
      pattern: "executeToolHandler"
    - from: "apps/web/src/lib/agent/tool-handlers.ts"
      to: "apps/web/src/lib/buyers.ts"
      via: "fetchBuyers, fetchBuyerById imports"
      pattern: "fetchBuyers|fetchBuyerById"
    - from: "apps/web/src/app/api/agent/chat/route.ts"
      to: "apps/web/src/lib/anthropic.ts"
      via: "anthropic client import"
      pattern: "anthropic"
---

<objective>
Build the complete backend infrastructure for the Research Agent: MongoDB conversation model, system prompt builder, tool definitions with handlers, and the SSE streaming API route with tool-use loop.

Purpose: Provides the entire server-side foundation so the frontend (Plan 02) can connect and stream agent responses.
Output: Working POST /api/agent/chat endpoint that receives messages + context, runs Claude Sonnet with tools, and streams SSE events.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/output.md — Full confirmed requirements with tool definitions, SSE event types, context shape
@.planning/phases/19-research-agent-chat-panel/19-RESEARCH.md — Architecture patterns, code examples, pitfalls

Key existing files to reference:
@apps/web/src/lib/anthropic.ts — Anthropic client singleton
@apps/web/src/lib/buyers.ts — fetchBuyers, fetchBuyerById query functions
@apps/web/src/lib/contracts.ts — fetchContracts, fetchContractById query functions
@apps/web/src/app/api/scanners/[id]/score-column/route.ts — SSE streaming pattern to follow exactly
@apps/web/src/models/scanner.ts — Scanner model (for write tool references)
@apps/web/src/models/signal.ts — Signal model
@apps/web/src/models/key-personnel.ts — KeyPersonnel model
@apps/web/src/models/spend-summary.ts — SpendSummary model
@apps/web/src/models/spend-transaction.ts — SpendTransaction model
@apps/web/src/models/board-document.ts — BoardDocument model
@apps/web/src/models/company-profile.ts — CompanyProfile model (for system prompt)
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChatConversation model + system prompt builder</name>
  <files>
    apps/web/src/models/chat-conversation.ts
    apps/web/src/lib/agent/system-prompt.ts
  </files>
  <action>
    **ChatConversation model (`apps/web/src/models/chat-conversation.ts`):**
    Create a Mongoose model following the existing model pattern (mongoose.models.X || mongoose.model). Schema:
    - `userId`: String, required, indexed
    - `title`: String, default "New conversation"
    - `context`: Schema.Types.Mixed (the page context at conversation start)
    - `messages`: Array of subdocuments with:
      - `role`: String, enum ["user", "assistant"], required
      - `content`: String, required
      - `toolCalls`: Array of { toolName: String, args: Schema.Types.Mixed, result: String } (optional, for assistant messages)
      - `timestamp`: Date, default Date.now
    - `lastMessageAt`: Date, indexed
    - Compound index: `{ userId: 1, lastMessageAt: -1 }`
    - Enable timestamps: true
    - Use _id: false on subdocuments for toolCalls
    - Export type via InferSchemaType

    **System prompt builder (`apps/web/src/lib/agent/system-prompt.ts`):**
    Export `buildSystemPrompt(context: AgentPageContext, companyProfile?: CompanyProfileData): string`

    Define the `AgentPageContext` interface:
    ```typescript
    export interface AgentPageContext {
      page: "dashboard" | "scanner" | "buyer_detail" | "contract_detail" | "contracts" | "buyers";
      scannerId?: string;
      scannerType?: string;
      scannerName?: string;
      scannerQuery?: string;
      scannerFilters?: Record<string, unknown>;
      buyerId?: string;
      buyerName?: string;
      buyerSector?: string;
      buyerRegion?: string;
      buyerOrgType?: string;
      contractId?: string;
      contractTitle?: string;
      contractBuyerName?: string;
      contractSector?: string;
      contractValue?: string;
      selectedRow?: Record<string, unknown>;
    }
    ```

    The system prompt structure:
    1. Role intro: "You are a procurement research assistant for TendHunt, a UK public sector sales intelligence platform."
    2. Data access section listing all available tools and what they query
    3. Current context section: dynamically built from context fields. Show page type, and for scanner pages show scanner name/type/query/filters, for buyer pages show buyer name/sector/region, for contract pages show contract title/buyer/value, for selected row show key fields.
    4. Company profile section (if provided): company name, sectors, capabilities, regions, idealContractDescription
    5. Guidelines section: always use tools for real data, never guess, format currency as GBP, dates as UK format, synthesize after gathering data, max 5 tool calls per response, keep responses concise and actionable.
  </action>
  <verify>
    - `pnpm typecheck` passes (run from repo root)
    - ChatConversation model file exists and exports default model + type
    - buildSystemPrompt function exists, accepts context + optional profile, returns string
  </verify>
  <done>
    ChatConversation MongoDB model ready for persistence. System prompt builder produces context-aware prompts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tool definitions, handlers, and SSE API route</name>
  <files>
    apps/web/src/lib/agent/tools.ts
    apps/web/src/lib/agent/tool-handlers.ts
    apps/web/src/app/api/agent/chat/route.ts
  </files>
  <action>
    **Tool definitions (`apps/web/src/lib/agent/tools.ts`):**
    Export `getToolDefinitions(): Anthropic.Tool[]` returning 9 read-only tool definitions in Anthropic's tool-use format. Each tool has name, description, and input_schema with typed properties:

    1. `query_buyers` — params: query?, sector?, region?, orgType?, minEnrichmentScore?, limit? (default 10, max 20)
    2. `query_contracts` — params: query?, sector?, region?, minValue?, maxValue?, status?, limit? (default 10, max 20)
    3. `query_signals` — params: organizationName?, signalType?, sector?, dateFrom?, dateTo?, limit? (default 10, max 20)
    4. `get_buyer_detail` — params: buyerId (required)
    5. `get_contract_detail` — params: contractId (required)
    6. `query_key_personnel` — params: buyerId?, role?, limit? (default 10, max 20)
    7. `query_spend_data` — params: buyerId (required)
    8. `query_board_documents` — params: buyerId?, committeeName?, dateFrom?, dateTo?, limit? (default 10, max 20)
    9. `web_search` — params: query (required). Description notes this searches the web for info not in internal data.

    Also include 3 write tool definitions:
    10. `create_scanner` — params: name (required), type (required, enum rfps/meetings/buyers), searchQuery?, description?
    11. `apply_scanner_filter` — params: scannerId (required), filters (required, object with sector?, region?, valueMin?, valueMax?)
    12. `add_scanner_column` — params: scannerId (required), name (required), prompt (required)

    **Tool handlers (`apps/web/src/lib/agent/tool-handlers.ts`):**
    Export `executeToolHandler(toolName: string, input: Record<string, unknown>, userId: string): Promise<{ summary: string; data: unknown; action?: { type: string; [key: string]: unknown } }>`

    Implement handlers for each tool:
    - `query_buyers`: Call `fetchBuyers(filters)` from `@/lib/buyers`. Select only essential fields (name, sector, region, orgType, enrichmentScore, contractCount). Return summary like "Found N buyers matching criteria".
    - `query_contracts`: Call `fetchContracts(filters)` from `@/lib/contracts`. Select only essential fields (title, buyerName, sector, valueMin, valueMax, status, deadlineDate). Return summary "Found N contracts".
    - `query_signals`: Query Signal model directly with filters (organizationName regex, signalType, sourceDate range). Limit to 20. Return summary "Found N signals".
    - `get_buyer_detail`: Call `fetchBuyerById(buyerId)` from `@/lib/buyers`. Return full buyer with contacts, signals, board docs, personnel. Return summary "Retrieved details for [name]".
    - `get_contract_detail`: Call `fetchContractById(contractId)` from `@/lib/contracts`. Return summary "Retrieved contract: [title]".
    - `query_key_personnel`: Query KeyPersonnel model. Filter by buyerId and/or role regex. Return summary "Found N personnel".
    - `query_spend_data`: Query SpendSummary by buyerId. If no summary exists, query SpendTransaction for aggregated data. Return summary "Retrieved spending data for buyer".
    - `query_board_documents`: Query BoardDocument model. Filter by buyerId, committeeName regex, meetingDate range. Return summary "Found N board documents".
    - `web_search`: For MVP, return { summary: "Web search not yet implemented", data: null }. Note in summary to ask user to try rephrasing with internal data tools.
    - `create_scanner`: Create scanner via `Scanner.create({ userId, name, type, searchQuery, description })`. Return summary and action `{ type: "navigate", url: "/scanners/[id]" }`.
    - `apply_scanner_filter`: Update scanner via `Scanner.findOneAndUpdate({ _id: scannerId, userId }, { $set: { filters } })`. Return summary "Applied filters to scanner".
    - `add_scanner_column`: Add AI column via `Scanner.findOneAndUpdate({ _id: scannerId, userId }, { $push: { aiColumns: { columnId: nanoid(), name, prompt } } })`. Import nanoid. Return summary "Added column [name]".

    Each handler wraps in try/catch, returning error summary on failure. Import `dbConnect` and call at start of each handler.

    **API route (`apps/web/src/app/api/agent/chat/route.ts`):**
    Follow the EXACT SSE pattern from `apps/web/src/app/api/scanners/[id]/score-column/route.ts`:

    ```typescript
    export async function POST(request: Request) {
      const { userId } = await auth();
      if (!userId) return Response.json({ error: "Not authenticated" }, { status: 401 });

      const { messages, context, conversationId } = await request.json();
      await dbConnect();

      // Load company profile for system prompt
      const profile = await CompanyProfile.findOne({ userId }).lean();
      const systemPrompt = buildSystemPrompt(context, profile);
      const tools = getToolDefinitions();

      const encoder = new TextEncoder();
      const stream = new ReadableStream({
        async start(controller) {
          const send = (event: Record<string, unknown>) => {
            controller.enqueue(encoder.encode(`data: ${JSON.stringify(event)}\n\n`));
          };

          try {
            let currentMessages = messages.map((m: { role: string; content: string }) => ({
              role: m.role as "user" | "assistant",
              content: m.content,
            }));

            // Sliding window: only last 10 messages to manage token budget
            if (currentMessages.length > 10) {
              currentMessages = currentMessages.slice(-10);
            }

            let iteration = 0;
            const MAX_ITERATIONS = 5;
            let continueLoop = true;

            while (continueLoop && iteration < MAX_ITERATIONS) {
              iteration++;

              const response = await anthropic.messages.create({
                model: "claude-sonnet-4-5-20250929",
                max_tokens: 4096,
                system: systemPrompt,
                messages: currentMessages,
                tools,
              });

              // Collect tool use blocks
              const toolUseBlocks = response.content.filter(b => b.type === "tool_use");
              const textBlocks = response.content.filter(b => b.type === "text");

              // Stream text blocks
              for (const block of textBlocks) {
                if (block.type === "text" && block.text) {
                  send({ type: "text_delta", content: block.text });
                }
              }

              // Process tool calls
              if (toolUseBlocks.length > 0) {
                const toolResults = [];
                for (const block of toolUseBlocks) {
                  if (block.type === "tool_use") {
                    send({ type: "tool_call_start", toolName: block.name, args: block.input });
                    const result = await executeToolHandler(block.name, block.input as Record<string, unknown>, userId);
                    send({
                      type: "tool_call_result",
                      toolName: block.name,
                      summary: result.summary,
                      ...(result.action ? { action: result.action } : {}),
                    });
                    toolResults.push({
                      type: "tool_result" as const,
                      tool_use_id: block.id,
                      content: JSON.stringify(result.data),
                    });
                  }
                }

                // Append assistant message + tool results for next iteration
                currentMessages.push({ role: "assistant", content: response.content });
                currentMessages.push({ role: "user", content: toolResults });
              }

              continueLoop = response.stop_reason === "tool_use";
            }

            // Save conversation to MongoDB (fire-and-forget)
            if (conversationId) {
              // Update existing conversation -- handled in Plan 03
            }

            send({ type: "done" });
          } catch (err) {
            send({ type: "error", message: err instanceof Error ? err.message : "Agent error" });
          }
          controller.close();
        },
      });

      return new Response(stream, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive",
        },
      });
    }
    ```

    Use `claude-sonnet-4-5-20250929` model as confirmed in requirements.
    Import `anthropic` from `@/lib/anthropic`.
    Import `auth` from `@clerk/nextjs/server`.
    Import `dbConnect` from `@/lib/mongodb`.
    Import `CompanyProfile` from `@/models/company-profile`.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - All 12 tool definitions exist in tools.ts
    - API route file exists at correct path
    - Tool handlers import existing query functions (fetchBuyers, fetchContracts, fetchBuyerById, fetchContractById)
  </verify>
  <done>
    Complete backend: 12 tools defined, handlers query real MongoDB data via existing functions, API route streams SSE events with tool-use loop, max 5 iterations, Sonnet model configured.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with no errors related to agent files
2. All 5 new files exist: model, system-prompt, tools, tool-handlers, route
3. ChatConversation model has userId index and lastMessageAt index
4. System prompt builder produces different output based on page context
5. Tool handlers reuse existing fetchBuyers, fetchContracts, fetchBuyerById, fetchContractById
6. API route follows same ReadableStream + TextEncoder pattern as score-column/route.ts
</verification>

<success_criteria>
- POST /api/agent/chat is a valid SSE endpoint that authenticates via Clerk, calls Claude Sonnet with tools, and streams events
- Tool loop runs at most 5 iterations before forcing completion
- All 9 read tools and 3 write tools are defined and handleable
- ChatConversation model ready for persistence
- System prompt dynamically injects page context and company profile
</success_criteria>

<output>
After completion, create `.planning/phases/19-research-agent-chat-panel/19-01-SUMMARY.md`
</output>
