---
phase: 06-buyer-intelligence-credits
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/buyers/[id]/reveal/route.ts
  - src/components/buyers/unlock-button.tsx
  - src/components/buyers/contacts-tab.tsx
  - src/app/(dashboard)/buyers/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can click 'Unlock Contacts' to reveal all contacts for a buyer organization"
    - "Clicking unlock deducts exactly 1 credit atomically (no double-spend)"
    - "Blur dissolves with ~300ms animation after unlock"
    - "Credit balance in sidebar updates immediately after unlock"
    - "Previously unlocked buyers remain visible without additional credit spend"
    - "Zero balance shows 'Get More Credits' button instead of unlock button"
    - "Already-unlocked buyer shows green Unlocked badge and no unlock button"
  artifacts:
    - path: "src/app/api/buyers/[id]/reveal/route.ts"
      provides: "Atomic credit deduction + ContactReveal creation"
      exports: ["POST"]
    - path: "src/components/buyers/unlock-button.tsx"
      provides: "Unlock Contacts CTA button with loading state and zero-balance handling"
  key_links:
    - from: "src/components/buyers/unlock-button.tsx"
      to: "/api/buyers/[id]/reveal"
      via: "POST fetch on click"
      pattern: "fetch.*reveal"
    - from: "src/components/buyers/unlock-button.tsx"
      to: "src/stores/credit-store.ts"
      via: "deductCredit() on success, setBalance on response"
      pattern: "useCreditStore"
    - from: "src/app/api/buyers/[id]/reveal/route.ts"
      to: "src/models/credit.ts"
      via: "CreditAccount.findOneAndUpdate with $gte filter"
      pattern: "findOneAndUpdate.*\\$gte.*\\$inc"
    - from: "src/app/api/buyers/[id]/reveal/route.ts"
      to: "src/models/contact-reveal.ts"
      via: "ContactReveal.create for persistence"
      pattern: "ContactReveal\\.create"
---

<objective>
Wire the contact reveal flow: atomic credit deduction API, unlock button with loading/disabled states, blur-to-reveal animation trigger, credit store integration for reactive sidebar update, and zero-balance upgrade prompt.

Purpose: Complete the monetization demo -- users spend credits to reveal contacts, demonstrating the business model to investors.
Output: Working end-to-end reveal flow from button click through credit deduction to contact visibility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-buyer-intelligence-credits/06-RESEARCH.md
@.planning/phases/06-buyer-intelligence-credits/06-01-SUMMARY.md
@src/models/credit.ts
@src/models/contact-reveal.ts
@src/stores/credit-store.ts
@src/components/buyers/contacts-tab.tsx
@src/app/(dashboard)/buyers/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reveal API route with atomic credit deduction and idempotency</name>
  <files>
    src/app/api/buyers/[id]/reveal/route.ts
  </files>
  <action>
    Create POST endpoint at `src/app/api/buyers/[id]/reveal/route.ts`:

    1. **Auth check**: `const { userId } = await auth()` -- return 401 if not authenticated
    2. **Params**: `const { id: buyerId } = await params` (Next.js 16 async params)
    3. **Validate**: `mongoose.isValidObjectId(buyerId)` -- return 400 if invalid
    4. **Connect**: `await dbConnect()`

    5. **Idempotency check** (CRED-04 + BUYER-07): `ContactReveal.findOne({ userId, buyerId })`
       - If already exists: fetch current balance, return `{ revealed: true, balance, message: "Already unlocked" }` with 200
       - This prevents double-spend if user clicks rapidly or refreshes

    6. **Atomic credit deduction** (CRED-02 + CRED-04): Single `CreditAccount.findOneAndUpdate()`:
       ```
       filter: { userId, balance: { $gte: 1 } }
       update: { $inc: { balance: -1, totalSpent: 1 } }
       options: { new: true }
       ```
       - If returns null: return `{ error: "Insufficient credits" }` with 402 status
       - The `$gte: 1` filter + `$inc: -1` is atomic at document level -- prevents negative balance even under concurrent requests

    7. **Create reveal record + transaction** in parallel:
       ```
       Promise.all([
         ContactReveal.create({ userId, buyerId }),
         CreditTransaction.create({
           userId,
           type: "CONTACT_REVEAL",
           amount: -1,
           description: `Unlocked contacts for ${buyerName}`,
           contactId: buyerId.toString(),
           balanceAfter: account.balance,
         }),
       ])
       ```
       - Fetch `buyerName` via `Buyer.findById(buyerId).select("name").lean()` before this step

    8. **Return**: `{ revealed: true, balance: account.balance }` with 200

    Error handling: Wrap entire handler in try/catch, return 500 with error message on unexpected failures.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the route exports a POST function. Verify the findOneAndUpdate uses `{ balance: { $gte: 1 } }` filter (not a separate find-then-update pattern).
  </verify>
  <done>
    POST /api/buyers/[id]/reveal exists with atomic credit deduction via single findOneAndUpdate, idempotency check (no double charge for already-revealed buyers), ContactReveal + CreditTransaction creation, and correct error responses (401 unauth, 400 invalid id, 402 insufficient credits).
  </done>
</task>

<task type="auto">
  <name>Task 2: Unlock button component with credit store integration and contacts-tab wiring</name>
  <files>
    src/components/buyers/unlock-button.tsx
    src/components/buyers/contacts-tab.tsx
    src/app/(dashboard)/buyers/[id]/page.tsx
  </files>
  <action>
    1. **Create UnlockButton component** at `src/components/buyers/unlock-button.tsx`:
       - "use client" component
       - Props: `buyerId: string`, `isUnlocked: boolean`, `onUnlocked: () => void` callback
       - Import `useCreditStore` from `@/stores/credit-store`
       - Local state: `isLoading` (boolean, false initially)

       **Render logic** per locked decisions:
       - If `isUnlocked`: return `null` (no button shown -- green Unlocked badge is on the header, handled by BuyerHeader)
       - If `balance === 0` and NOT unlocked: render "Get More Credits" button (variant="default") that navigates to `/pricing` or shows inline prompt. Use `<Link href="/pricing">` wrapped in Button. Style: prominent, no Unlock icon.
       - Otherwise: render "Unlock Contacts (1 Credit)" button with Lock icon

       **Click handler** (for unlock button):
       - Set `isLoading = true`, disable button immediately (prevents rapid double-click per CRED-04)
       - `fetch("/api/buyers/${buyerId}/reveal", { method: "POST" })`
       - On success (200): read `data.balance` from response, call `store.setBalance(data.balance)` to sync sidebar, call `store.deductCredit()` ONLY for the animation trigger (but use server balance as source of truth), call `onUnlocked()` callback to trigger parent re-render
       - Actually simpler: just call `store.setBalance(data.balance)` and trigger animation separately. Set `store.setIsAnimating(true)`, then the CreditBalance component auto-resets after 600ms.
       - On 402: show toast "Insufficient credits" (or update local state to show "Get More Credits")
       - On error: show toast "Failed to unlock contacts"
       - Finally: set `isLoading = false`

       **Button styling**: per locked decision -- instant, no confirmation dialog. Button uses `variant="default"` with Lock icon when locked, disabled + Loader2 spinner when loading.

    2. **Update ContactsTab** at `src/components/buyers/contacts-tab.tsx`:
       - Add `onUnlocked?: () => void` to props
       - Above the contact list, render the UnlockButton component (per locked decision: "Single Unlock Contacts CTA button at top of contacts tab, above the contact list")
       - The UnlockButton receives `buyerId`, `isUnlocked`, and `onUnlocked` props

    3. **Update buyer detail page** at `src/app/(dashboard)/buyers/[id]/page.tsx`:
       - The page is a server component that passes `isUnlocked` to BuyerTabs
       - To handle the reveal flow (server component can't have state), extract the buyer detail content into a client wrapper component `BuyerDetailClient` (inline in the same file or a separate component)
       - `BuyerDetailClient` manages local `isUnlocked` state (initialized from server data)
       - When `onUnlocked` fires from UnlockButton: set local `isUnlocked = true`, which causes contacts to unblur with the CSS transition (~300ms blur dissolve per locked decision)
       - Pass `isUnlocked` and `onUnlocked` through BuyerTabs to ContactsTab

    The full flow:
    1. User sees contacts with blurred email/phone
    2. User clicks "Unlock Contacts (1 Credit)" button at top of contacts tab
    3. Button disables, shows loading spinner
    4. POST /api/buyers/[id]/reveal succeeds
    5. Credit store updates -> sidebar counter animates (10 -> 9)
    6. Local `isUnlocked` flips to true -> CSS `blur-sm` transitions to `blur-none` over 300ms
    7. Copy-to-clipboard buttons appear on contact cards
    8. Button disappears (isUnlocked = true)
    9. On page refresh: server fetches ContactReveal, returns isUnlocked=true, contacts render unblurred
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors. Run `npm run build` to confirm the app builds. Verify UnlockButton renders with correct text based on unlock state and balance. Verify the reveal flow updates both local state and credit store.
  </verify>
  <done>
    UnlockButton shows "Unlock Contacts (1 Credit)" when locked with credits, "Get More Credits" when zero balance, and disappears when already unlocked. Clicking unlock disables button, calls reveal API, updates credit store (sidebar animates), and triggers blur-to-reveal transition on all contact cards. Previously unlocked buyers show contacts unblurred on page load. Flow is idempotent and double-click safe.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` completes successfully
- POST /api/buyers/[id]/reveal uses atomic findOneAndUpdate with $gte filter
- UnlockButton renders correctly in all 3 states (locked+credits, locked+zero, unlocked)
- Clicking unlock triggers blur dissolve animation on contacts
- Credit balance in sidebar updates reactively after reveal
- Already-revealed buyers show contacts unblurred on fresh page load
- Rapid double-clicks result in only 1 credit deduction (idempotency + button disable)
</verification>

<success_criteria>
1. Reveal API deducts exactly 1 credit atomically with no double-spend
2. Idempotent: re-revealing an already-unlocked buyer returns success without deducting
3. Button shows loading state during API call, disables to prevent rapid clicks
4. Blur dissolves with ~300ms CSS transition after successful reveal
5. Sidebar credit counter updates immediately via Zustand store
6. Zero balance shows "Get More Credits" linking to pricing page
7. Unlocked buyers persist across page refreshes (ContactReveal record)
8. Green "Unlocked" badge appears on buyer header when revealed
</success_criteria>

<output>
After completion, create `.planning/phases/06-buyer-intelligence-credits/06-03-SUMMARY.md`
</output>
