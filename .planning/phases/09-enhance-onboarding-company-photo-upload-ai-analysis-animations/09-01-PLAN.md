---
phase: 09-enhance-onboarding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/linkedin-scraper.ts
  - src/lib/fetch-web-content.ts
  - src/app/api/profile/generate/route.ts
  - src/models/company-profile.ts
  - src/app/onboarding/_actions.ts
autonomous: true

must_haves:
  truths:
    - "Logo URL is extracted from LinkedIn Apify response when available"
    - "og:image URL is extracted from company website HTML as fallback"
    - "Profile generation API returns logoUrl alongside the AI profile"
    - "CompanyProfile MongoDB model stores logoUrl field"
    - "completeOnboarding server action persists logoUrl to database"
  artifacts:
    - path: "src/lib/linkedin-scraper.ts"
      provides: "LinkedIn logo extraction"
      contains: "logoUrl"
    - path: "src/lib/fetch-web-content.ts"
      provides: "og:image extraction from raw HTML"
      exports: ["extractOgImage"]
    - path: "src/app/api/profile/generate/route.ts"
      provides: "logoUrl in API response"
      contains: "logoUrl"
    - path: "src/models/company-profile.ts"
      provides: "logoUrl field in CompanyProfile schema"
      contains: "logoUrl"
    - path: "src/app/onboarding/_actions.ts"
      provides: "logoUrl accepted in completeOnboarding"
      contains: "logoUrl"
  key_links:
    - from: "src/lib/linkedin-scraper.ts"
      to: "src/app/api/profile/generate/route.ts"
      via: "LinkedInCompanyData.logoUrl field"
      pattern: "linkedInData\\.logoUrl"
    - from: "src/lib/fetch-web-content.ts"
      to: "src/app/api/profile/generate/route.ts"
      via: "extractOgImage() called for fallback"
      pattern: "extractOgImage"
    - from: "src/app/api/profile/generate/route.ts"
      to: "src/app/onboarding/_actions.ts"
      via: "logoUrl field in response consumed by wizard then passed to completeOnboarding"
      pattern: "logoUrl"
---

<objective>
Extract company logo URL from LinkedIn Apify response and website og:image, thread it through the profile generation API and persistence layer.

Purpose: The onboarding wizard needs a company logo to display in the profile review and throughout the app. Instead of manual upload, the logo is auto-extracted from existing data sources (LinkedIn scraper response, website HTML meta tags) during the AI profile generation step.

Output: Modified linkedin-scraper.ts, fetch-web-content.ts, route.ts, company-profile.ts, and _actions.ts with logoUrl field threaded through the entire backend pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/linkedin-scraper.ts
@src/lib/fetch-web-content.ts
@src/app/api/profile/generate/route.ts
@src/models/company-profile.ts
@src/app/onboarding/_actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract logo URL from LinkedIn Apify response and website og:image</name>
  <files>src/lib/linkedin-scraper.ts, src/lib/fetch-web-content.ts</files>
  <action>
**linkedin-scraper.ts changes:**

1. Update `LinkedInCompanyData` interface to add `logoUrl: string | null` as a third field alongside `profile` and `posts`.

2. In `formatCompanyProfile()`, BEFORE the text formatting, extract the logo URL from the raw company object. The `dev_fusion~Linkedin-Company-Scraper` actor returns company data with image fields. Try these field names in order (first non-empty wins): `company.logo`, `company.companyLogo`, `company.logoUrl`, `company.profilePicture`, `company.companyLogoUrl`, `company.logoResolutionResult`. If the value is a string starting with "http", use it. If it's an object with a `url` or `rootUrl` property, use that. Store as a local variable.

3. Change `formatCompanyProfile()` return type from `string | null` to `{ text: string | null; logoUrl: string | null }`. Return an object with both the formatted text (existing logic) and the extracted logoUrl.

4. Update `scrapeLinkedInCompany()`:
   - Where it calls `formatCompanyProfile()`, destructure the return into `{ text, logoUrl }`.
   - Change the profile assignment: `const profile = ... ? formatted.text : null;`
   - Add logoUrl to the return: `return { profile, posts, logoUrl: formatted?.logoUrl ?? null };`
   - Update the default returns (early returns and catch block) to include `logoUrl: null`.

**fetch-web-content.ts changes:**

1. Add a new exported function `extractOgImage(html: string): string | null` that:
   - Takes raw HTML string (BEFORE `stripHtmlNoise` is called).
   - Uses a regex to find `<meta property="og:image" content="...">` (case-insensitive, handles both single and double quotes, handles self-closing tags with or without slash).
   - Regex pattern: `/<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/i`
   - Also try the reverse order (content before property): `/<meta[^>]+content=["']([^"']+)["'][^>]+property=["']og:image["']/i`
   - Return the first matched URL, or null if no match.
   - Only return URLs that start with "http" (skip relative paths and data URIs).

2. In the existing `fetchWebContent()` function, BEFORE calling `stripHtmlNoise(html)`, call `extractOgImage(html)` and... actually, DON'T modify fetchWebContent. The og:image extraction needs to happen in the API route where we have access to raw HTML. Instead, add a new exported function `fetchRawHtml(url: string): Promise<string | null>` that does the same fetch as `fetchWebContent` but returns the raw HTML WITHOUT stripping. Actually, this is simpler: just export `extractOgImage` as a standalone function. The API route will call `fetchWebContent` for text (existing behavior) and separately use the raw HTML for og:image.

Wait -- looking at the current code, `fetchWebContent` fetches HTML, strips it, and returns text. We don't have access to the raw HTML in the API route. The simplest approach: **modify `fetchWebContent` to return both** the cleaned text AND the og:image URL.

Change `fetchWebContent` return type from `Promise<string | null>` to `Promise<{ text: string | null; ogImage: string | null }>`. Extract og:image from raw HTML before stripping, return both. Update all callers (there's only one: `src/app/api/profile/generate/route.ts` which chains `.then(html => html ? extractWebInfo(html, "company website") : null)` -- update that to use `.text`).

Actually, to minimize changes and keep backward compatibility, instead do this:
- Export `extractOgImage` as a standalone function.
- Add a new exported function `fetchWebContentWithOgImage(url: string): Promise<{ text: string | null; ogImage: string | null }>` that does the same fetch but returns both. Internally, it gets raw HTML, extracts og:image, strips HTML, returns both.
- Keep existing `fetchWebContent` unchanged for backward compatibility (though we could refactor later).

This is cleaner. The API route will call `fetchWebContentWithOgImage` instead of `fetchWebContent`.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. Should compile without errors. Verify `LinkedInCompanyData` has `logoUrl` field, `extractOgImage` function is exported, and `fetchWebContentWithOgImage` is exported.
  </verify>
  <done>
- LinkedInCompanyData interface has `logoUrl: string | null`
- formatCompanyProfile returns `{ text, logoUrl }` with logo extracted from Apify response
- scrapeLinkedInCompany returns `logoUrl` alongside profile and posts
- extractOgImage function exported from fetch-web-content.ts
- fetchWebContentWithOgImage function exported from fetch-web-content.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire logoUrl through API route, model, and server action</name>
  <files>src/app/api/profile/generate/route.ts, src/models/company-profile.ts, src/app/onboarding/_actions.ts</files>
  <action>
**src/app/api/profile/generate/route.ts changes:**

1. Import `fetchWebContentWithOgImage` instead of (or in addition to) `fetchWebContent`.

2. Change the website content fetching to use `fetchWebContentWithOgImage`:
   ```
   const websitePromise = companyInfo?.website?.trim()
     ? fetchWebContentWithOgImage(companyInfo.website)
     : Promise.resolve({ text: null, ogImage: null });
   ```

3. After `Promise.allSettled`, extract the og:image URL:
   ```
   let ogImageUrl: string | null = null;
   if (websiteResult.status === "fulfilled" && websiteResult.value) {
     ogImageUrl = websiteResult.value.ogImage;
     // For the text extraction, use .text
     const websiteText = websiteResult.value.text;
     if (websiteText) {
       // Feed into extractWebInfo as before
     }
   }
   ```
   Note: The `extractWebInfo` call needs the text, not the raw HTML. So chain: get `websiteResult.value.text`, if truthy, pass to `extractWebInfo()`. This changes the existing promise chain slightly -- the website promise now resolves to `{ text, ogImage }` instead of going through extractWebInfo in the promise chain. Move the extractWebInfo call to after Promise.allSettled.

4. Extract logoUrl from LinkedIn data:
   ```
   let linkedInLogoUrl: string | null = null;
   if (linkedInResult.status === "fulfilled") {
     linkedInLogoUrl = linkedInResult.value.logoUrl;
   }
   ```

5. Determine final logoUrl with priority: LinkedIn logo first, og:image second:
   ```
   const logoUrl = linkedInLogoUrl || ogImageUrl || null;
   ```

6. Change the API response from `return Response.json({ profile })` to `return Response.json({ profile, logoUrl })`. Do NOT include logoUrl in the Claude prompt -- it's extracted directly from data, not AI-generated.

7. Also update the "no content" early return to include `logoUrl: null`:
   ```
   return Response.json({ profile: null, logoUrl: null, warning: "..." });
   ```

**src/models/company-profile.ts changes:**

Add `logoUrl: { type: String, default: "" }` to the companyProfileSchema, after `linkedinUrl`.

**src/app/onboarding/_actions.ts changes:**

Add `logoUrl?: string` to the `ProfileData` interface (optional because older calls may not have it). It will be spread into the CompanyProfile via `...profileData` in the findOneAndUpdate call, so no other changes needed -- the spread already handles all fields.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. Should compile without errors. Check that:
1. The API route returns `{ profile, logoUrl }` shape.
2. CompanyProfile model has `logoUrl` field.
3. _actions.ts ProfileData interface includes `logoUrl`.
  </verify>
  <done>
- Profile generation API returns `{ profile, logoUrl }` where logoUrl is LinkedIn logo (priority) or og:image (fallback) or null
- CompanyProfile MongoDB schema has logoUrl field
- completeOnboarding server action accepts and persists logoUrl
- logoUrl is NOT sent to Claude -- extracted directly from data sources
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no type errors across the modified files)
2. LinkedInCompanyData interface includes `logoUrl: string | null`
3. CompanyProfile Mongoose schema includes `logoUrl` field
4. API route returns `{ profile, logoUrl }` (grep for `Response.json.*logoUrl`)
5. Server action ProfileData interface includes `logoUrl`
</verification>

<success_criteria>
The entire backend pipeline for logo auto-extraction is complete: LinkedIn Apify response provides logo URL (priority), website og:image provides fallback, the profile generation API returns logoUrl alongside the AI profile, and the persistence layer stores it. No manual upload, no R2 storage for logos -- just a URL string.
</success_criteria>

<output>
After completion, create `.planning/phases/09-enhance-onboarding-company-photo-upload-ai-analysis-animations/09-01-SUMMARY.md`
</output>
