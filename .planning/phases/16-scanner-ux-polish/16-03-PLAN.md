---
phase: 16-scanner-ux-polish
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/components/scanners/grid/custom-renderers.ts
  - src/components/scanners/grid/cell-content.ts
  - src/components/scanners/scanner-filter-toolbar.tsx
autonomous: true

must_haves:
  truths:
    - "When a score badge transitions from loading to complete, there is a brief scale-up pop animation on the score circle"
    - "Filter chips animate in when a filter is applied and animate out when removed"
    - "Animations are subtle and do not delay interaction — purely visual polish"
  artifacts:
    - path: "src/components/scanners/grid/custom-renderers.ts"
      provides: "Score badge with completion pop animation"
    - path: "src/components/scanners/scanner-filter-toolbar.tsx"
      provides: "Filter chips with CSS transition animations"
  key_links:
    - from: "src/components/scanners/grid/custom-renderers.ts"
      to: "score-badge renderer"
      via: "Canvas Date.now()-based animation timing for scale pop"
      pattern: "score.*pop|scale.*anim|complet.*time"
---

<objective>
Add polished animations for AI score completion (canvas-based pop effect on score badges) and filter chip add/remove transitions (CSS-based).

Purpose: Visual polish that makes the scoring and filtering feel responsive and alive, enhancing the overall product quality for investor demos.

Output: Score badges pop on completion; filter chips animate in/out smoothly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-scanner-ux-polish/16-01-SUMMARY.md
@src/components/scanners/grid/custom-renderers.ts
@src/components/scanners/scanner-filter-toolbar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add canvas-based score completion pop animation to score-badge renderer</name>
  <files>
    src/components/scanners/grid/custom-renderers.ts
  </files>
  <action>
    The score-badge renderer currently transitions instantly from spinning-arc (isLoading) to filled-circle (score != null). Add a brief "pop" scale animation when a score first appears.

    **Add a completion timestamp cache:**
    ```typescript
    // Track when each cell's score first appeared (for pop animation)
    const scoreCompletionTime = new Map<string, number>();
    ```

    **Modify the ScoreBadgeData interface:**
    Add an optional `cacheKey?: string` field (will be "columnId:entityId") so the renderer can track per-cell animation state.

    **Update `createScoreBadgeCell`:**
    Accept an optional `cacheKey` parameter and pass it through:
    ```typescript
    export function createScoreBadgeCell(
      score: number | null,
      isLoading: boolean,
      isQueued?: boolean,
      cacheKey?: string
    ): ScoreBadgeCell {
      return {
        kind: GridCellKind.Custom,
        allowOverlay: false,
        copyData: score != null ? score.toFixed(1) : "",
        data: { kind: "score-badge", score, isLoading, isQueued, cacheKey },
      };
    }
    ```

    **Update cell-content.ts** (the file that calls createScoreBadgeCell) to pass the cacheKey. Find where `createScoreBadgeCell` is called and add the composite key as the 4th argument: `createScoreBadgeCell(entry.score ?? null, !!entry.isLoading, !!entry.isQueued, \`${meta.aiColumnId}:${entityId}\`)`.

    **In the score-badge draw function, add pop animation logic:**

    In the branch where `score != null` (not loading, not queued), BEFORE drawing the filled circle:

    ```typescript
    // Pop animation: scale up briefly when score first appears
    const POP_DURATION = 300; // ms
    let scale = 1;

    if (cacheKey) {
      const now = Date.now();
      if (!scoreCompletionTime.has(cacheKey)) {
        scoreCompletionTime.set(cacheKey, now);
      }
      const elapsed = now - scoreCompletionTime.get(cacheKey)!;
      if (elapsed < POP_DURATION) {
        // Ease-out bounce: overshoot to 1.2x then settle to 1.0x
        const t = elapsed / POP_DURATION;
        const easeOut = 1 - Math.pow(1 - t, 3); // cubic ease-out
        scale = 1 + 0.2 * (1 - easeOut); // starts at 1.2, ends at 1.0
        // Return true to request continued redraws during animation
      }
    }
    ```

    Then apply the scale transform to the circle and text drawing:
    ```typescript
    const animRadius = radius * scale;

    // Filled circle with score
    const color = getScoreColor(score);
    ctx.beginPath();
    ctx.arc(cx, cy, animRadius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // Optional: subtle glow ring during pop
    if (scale > 1.01) {
      ctx.beginPath();
      ctx.arc(cx, cy, animRadius + 3, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.3 * (scale - 1) / 0.2; // fade with animation
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Score text (slightly larger during pop)
    ctx.fillStyle = "#ffffff";
    ctx.font = `600 ${Math.round(11 * scale)}px ${theme.fontFamily}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(score.toFixed(1), cx, cy);
    ```

    Return `true` from the draw function while `elapsed < POP_DURATION` to request continued redraws (the existing ~60ms interval from the scoring useEffect in scanner-data-grid.tsx will drive the animation; after scoring stops, the animation will complete within the final few frames since the grid already redraws on score state changes).

    **Memory management:** When `scoreCompletionTime` grows beyond 1000 entries, clear the oldest half. This prevents memory leaks for long sessions. Add a simple cleanup check after setting a new entry:
    ```typescript
    if (scoreCompletionTime.size > 1000) {
      const entries = [...scoreCompletionTime.entries()].sort((a, b) => a[1] - b[1]);
      for (let i = 0; i < 500; i++) scoreCompletionTime.delete(entries[i][0]);
    }
    ```

    **Constraint:** No framer-motion. This is pure canvas + Date.now() timing, matching the existing pattern used for the spinning arc and shimmer animations in the same file.
  </action>
  <verify>
    `npx tsc --noEmit` passes.
    When a score is computed (transitions from loading to scored), the score badge briefly scales up then settles to normal size.
    After animation completes (300ms), the badge renders at normal size with no ongoing animation overhead.
  </verify>
  <done>
    Score badges display a brief pop/scale animation when transitioning from loading to scored state. Animation uses canvas Date.now() timing (no framer-motion). Memory-safe with cache cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CSS transition animations to filter chips in filter toolbar</name>
  <files>
    src/components/scanners/scanner-filter-toolbar.tsx
  </files>
  <action>
    The filter chip toolbar created in Plan 01 renders chips instantly. Add smooth entry/exit animations using Tailwind CSS transitions (tw-animate-css is available).

    **Entry animation for chips:**
    Each chip element should have these Tailwind classes for a smooth appear effect:
    `animate-in fade-in-0 zoom-in-95 duration-200`

    This makes chips fade+scale in when they appear. The tw-animate-css library (already in the project) provides these utility classes.

    **Exit animation (chip removal):**
    CSS exit animations require the element to remain in the DOM briefly after removal. Implement a simple approach:

    1. Track chips that are being removed in local state:
       ```typescript
       const [removingChips, setRemovingChips] = useState<Set<string>>(new Set());
       ```

    2. When user clicks X on a chip, instead of immediately calling `setColumnFilter`, add the chip key to `removingChips` and set a 150ms timeout:
       ```typescript
       function handleRemoveChip(columnId: string, value: string) {
         const chipKey = `${columnId}:${value}`;
         setRemovingChips(prev => new Set(prev).add(chipKey));
         setTimeout(() => {
           const current = useScannerStore.getState().columnFilters[columnId] ?? [];
           setColumnFilter(columnId, current.filter(v => v !== value));
           setRemovingChips(prev => {
             const next = new Set(prev);
             next.delete(chipKey);
             return next;
           });
         }, 150);
       }
       ```

    3. Chips in `removingChips` set get exit animation classes:
       `animate-out fade-out-0 zoom-out-95 duration-150`

    **Clear all animation:**
    When "Clear filters" is clicked, add ALL current chip keys to removingChips, then clear after 150ms:
    ```typescript
    function handleClearAll() {
      const allKeys = new Set<string>();
      Object.entries(columnFilters).forEach(([colId, vals]) => {
        vals.forEach(v => allKeys.add(`${colId}:${v}`));
      });
      setRemovingChips(allKeys);
      setTimeout(() => {
        clearColumnFilters();
        setRemovingChips(new Set());
      }, 150);
    }
    ```

    **Toolbar container transition:**
    The toolbar itself should have a smooth height transition when it appears/disappears. Since the component returns null when no filters are active, wrap the content in a div with `transition-all duration-200` and let the parent handle the mount/unmount. Alternatively, always render but use `max-h-0 overflow-hidden` when empty and `max-h-20` when active — this gives a smooth collapse effect:

    Instead of returning null when no active filters, always render:
    ```tsx
    const hasFilters = activeFilters.length > 0 || removingChips.size > 0;
    return (
      <div className={`flex flex-wrap items-center gap-2 px-1 transition-all duration-200 overflow-hidden ${hasFilters ? 'max-h-20 opacity-100 py-0' : 'max-h-0 opacity-0'}`}>
        {/* ... chips ... */}
      </div>
    );
    ```

    **Constraint:** No framer-motion per Phase 9 decision. Use tw-animate-css utility classes only.
  </action>
  <verify>
    `npx tsc --noEmit` passes.
    When a filter is applied (via header menu checkboxes), the chip fades+scales in smoothly.
    When a chip is removed (X click), it fades+scales out before disappearing.
    When "Clear filters" is clicked, all chips animate out together.
    The toolbar bar itself smoothly collapses when the last filter is removed.
  </verify>
  <done>
    Filter chips animate in (fade+zoom, 200ms) and out (fade+zoom, 150ms). Clear all triggers simultaneous exit animations. Toolbar smoothly collapses/expands. All animations use tw-animate-css, no framer-motion.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Score badges show a brief pop effect when transitioning from loading → scored
3. Pop animation completes within 300ms and has no ongoing render cost after
4. Filter chips animate in smoothly when filters are applied
5. Filter chips animate out smoothly when removed individually or via "Clear filters"
6. No framer-motion in any of the modified files
</verification>

<success_criteria>
- Score badge completion pop animation works for all score-mode AI columns
- Filter chip entry/exit animations are smooth and feel polished
- All animations use canvas Date.now() timing or tw-animate-css — zero framer-motion
- No performance degradation (animations are brief and self-terminating)
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-scanner-ux-polish/16-03-SUMMARY.md`
</output>
