---
phase: 22-crm-pipeline-procurement-inbox
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/models/pipeline-card.ts
  - apps/web/src/models/pipeline-card-note.ts
  - apps/web/src/lib/constants/pipeline-stages.ts
  - apps/web/src/types/inbox.ts
  - apps/web/src/app/api/inbox/route.ts
  - apps/web/src/app/api/inbox/[id]/route.ts
  - apps/web/src/app/api/inbox/reorder/route.ts
  - apps/web/src/app/api/inbox/[id]/notes/route.ts
autonomous: true

must_haves:
  truths:
    - "PipelineCard model stores polymorphic entity references (contract, buyer, signal) with denormalized display fields"
    - "API endpoints create, list, update, delete, and reorder pipeline cards for the authenticated user"
    - "Unique compound index prevents duplicate cards for the same entity per user"
    - "Bulk position update endpoint handles cross-column drag-and-drop reordering"
    - "Notes can be created and listed for any pipeline card"
  artifacts:
    - path: "apps/web/src/models/pipeline-card.ts"
      provides: "PipelineCard Mongoose model with stage enum, position, polymorphic entity ref"
      contains: "pipelineCardSchema"
    - path: "apps/web/src/models/pipeline-card-note.ts"
      provides: "PipelineCardNote Mongoose model for card comments"
      contains: "pipelineCardNoteSchema"
    - path: "apps/web/src/lib/constants/pipeline-stages.ts"
      provides: "Stage enum, labels, colors, icons shared between FE and BE"
      exports: ["PIPELINE_STAGES", "STAGE_ORDER", "PipelineStage"]
    - path: "apps/web/src/types/inbox.ts"
      provides: "TypeScript types for pipeline card, note, stage, entity type"
      exports: ["PipelineCardData", "PipelineNoteData", "PipelineEntityType"]
    - path: "apps/web/src/app/api/inbox/route.ts"
      provides: "GET list cards, POST create card"
      exports: ["GET", "POST"]
    - path: "apps/web/src/app/api/inbox/[id]/route.ts"
      provides: "GET/PATCH/DELETE single card"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "apps/web/src/app/api/inbox/reorder/route.ts"
      provides: "PATCH bulk position update on drag-end"
      exports: ["PATCH"]
    - path: "apps/web/src/app/api/inbox/[id]/notes/route.ts"
      provides: "GET/POST notes for a card"
      exports: ["GET", "POST"]
  key_links:
    - from: "apps/web/src/app/api/inbox/route.ts"
      to: "apps/web/src/models/pipeline-card.ts"
      via: "Mongoose findOneAndUpdate with upsert"
      pattern: "PipelineCard\\.findOneAndUpdate"
    - from: "apps/web/src/app/api/inbox/reorder/route.ts"
      to: "apps/web/src/models/pipeline-card.ts"
      via: "bulkWrite for batch position updates"
      pattern: "PipelineCard\\.bulkWrite"
---

<objective>
Create the data layer for the CRM Pipeline: Mongoose models, shared constants, TypeScript types, and all API routes for CRUD operations, reordering, and notes.

Purpose: Provides the complete backend infrastructure that the Kanban board UI and "Send to Inbox" buttons will consume. This is the foundation all other plans depend on.
Output: 2 Mongoose models, shared stage constants, TypeScript types, 4 API route files (8 endpoints total).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-crm-pipeline-procurement-inbox/22-RESEARCH.md

Reference existing patterns:
@apps/web/src/models/scanner.ts (Mongoose model pattern with InferSchemaType)
@apps/web/src/app/api/scanners/route.ts (API route pattern with Clerk auth)
@apps/web/src/app/api/scanners/[id]/route.ts (single entity CRUD pattern)
@apps/web/src/lib/constants/sectors.ts (shared constants pattern)
@apps/web/src/types/index.ts (types export pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mongoose models and shared constants</name>
  <files>
    apps/web/src/models/pipeline-card.ts
    apps/web/src/models/pipeline-card-note.ts
    apps/web/src/lib/constants/pipeline-stages.ts
    apps/web/src/types/inbox.ts
  </files>
  <action>
**1. `apps/web/src/lib/constants/pipeline-stages.ts`** — Stage configuration shared between frontend and backend:
- Export `PipelineStage` type union: `"NEW" | "QUALIFIED" | "PREPARING_BID" | "SUBMITTED" | "WON" | "LOST"`
- Export `STAGE_ORDER` array: `["NEW", "QUALIFIED", "PREPARING_BID", "SUBMITTED", "WON", "LOST"]` — defines column display order
- Export `PIPELINE_STAGES` config object keyed by stage with: `label` (human name), `color` (Tailwind bg class for column header), `textColor` (Tailwind text class), `icon` (lucide icon name string). Use procurement-appropriate colors: NEW=blue, QUALIFIED=indigo, PREPARING_BID=amber, SUBMITTED=purple, WON=emerald, LOST=red.
- Export `PipelineEntityType` union: `"contract" | "buyer" | "signal"` — per user decision, scanner results use the underlying entity type, NOT "scanner_result"

**2. `apps/web/src/types/inbox.ts`** — TypeScript types:
- `PipelineCardData` interface: `_id: string`, `userId: string`, `entityType: PipelineEntityType`, `entityId: string`, `title: string`, `subtitle?: string`, `value?: number`, `currency?: string`, `deadlineDate?: string`, `sector?: string`, `buyerName?: string`, `logoUrl?: string`, `stage: PipelineStage`, `position: number`, `priority: "LOW" | "MEDIUM" | "HIGH"`, `addedBy: "manual" | "auto_rule"`, `autoRuleId?: string`, `stageChangedAt?: string`, `isArchived: boolean`, `createdAt: string`, `updatedAt: string`
- `PipelineNoteData` interface: `_id: string`, `cardId: string`, `userId: string`, `content: string`, `createdAt: string`
- `ReorderPayload` interface: `{ stage: PipelineStage, cardIds: string[], movedCard?: { cardId: string, fromStage: PipelineStage }, sourceColumn?: { stage: PipelineStage, cardIds: string[] } }`

**3. `apps/web/src/models/pipeline-card.ts`** — PipelineCard Mongoose model:
- Follow existing model pattern: `mongoose.models.PipelineCard || mongoose.model('PipelineCard', schema)`
- Schema fields per research Pattern 1: userId (String, required, indexed), entityType (String, enum matching PipelineEntityType, required), entityId (ObjectId, required), title (String, required), subtitle (String), value (Number), currency (String, default "GBP"), deadlineDate (Date), sector (String), buyerName (String), logoUrl (String), stage (String, enum matching PipelineStage values, default "NEW", indexed), position (Number, default 0), priority (String, enum ["LOW","MEDIUM","HIGH"], default "LOW"), addedBy (String, enum ["manual","auto_rule"], default "manual"), autoRuleId (String), stageChangedAt (Date), isArchived (Boolean, default false, indexed)
- Enable timestamps: true
- Add compound indexes: `{ userId: 1, stage: 1, position: 1 }`, `{ userId: 1, entityType: 1, entityId: 1 }` (unique), `{ userId: 1, isArchived: 1 }`
- Export InferSchemaType and the model

**4. `apps/web/src/models/pipeline-card-note.ts`** — PipelineCardNote Mongoose model:
- Schema: cardId (ObjectId, required, ref "PipelineCard", indexed), userId (String, required), content (String, required, maxlength 2000)
- Enable timestamps: true
- Index: `{ cardId: 1, createdAt: -1 }`
- Export InferSchemaType and the model

**5. `apps/web/src/types/inbox.ts`** — Import types from constants file. Use `import type` for PipelineStage and PipelineEntityType.
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to confirm no type errors in the new files.
  </verify>
  <done>
PipelineCard model has all fields, compound indexes (including unique dedup index), and timestamps. PipelineCardNote model has cardId ref, content, and timestamps. Shared constants export stage config and type unions. Types file exports all interfaces.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API routes for CRUD, reorder, and notes</name>
  <files>
    apps/web/src/app/api/inbox/route.ts
    apps/web/src/app/api/inbox/[id]/route.ts
    apps/web/src/app/api/inbox/reorder/route.ts
    apps/web/src/app/api/inbox/[id]/notes/route.ts
  </files>
  <action>
All API routes follow the existing pattern: `import { auth } from "@clerk/nextjs/server"`, check `userId`, call `dbConnect()`, then query. Use `Response.json()`.

**1. `apps/web/src/app/api/inbox/route.ts`** — List + Create:
- `GET`: Auth check. Find all PipelineCards where `{ userId, isArchived: false }`, sort by `{ stage: 1, position: 1 }`, lean(). Return `{ cards }`.
- `POST`: Auth check. Parse request body. Use `findOneAndUpdate` with filter `{ userId, entityType: body.entityType, entityId: body.entityId }` and `$setOnInsert` for all fields (title, subtitle, value, currency, deadlineDate, sector, buyerName, logoUrl, stage "NEW", addedBy "manual", position). For position, compute `await PipelineCard.countDocuments({ userId, stage: "NEW", isArchived: false })` to place at end. Return `{ card }` with status 201.

**2. `apps/web/src/app/api/inbox/[id]/route.ts`** — Single card operations:
- `GET`: Auth check. `findOne({ _id: id, userId })`. Return 404 if not found. Return `{ card }`.
- `PATCH`: Auth check. Whitelist updateable fields: `stage`, `priority`, `isArchived`. If stage is changing, set `stageChangedAt: new Date()`. If `isArchived` is being set to true, set `archivedAt: new Date()`. Use `findOneAndUpdate({ _id: id, userId }, { $set: updates }, { new: true })`. Return `{ card }`.
- `DELETE`: Auth check. `deleteOne({ _id: id, userId })`. Also delete associated notes: `PipelineCardNote.deleteMany({ cardId: id })`. Return `{ success: true }`.

**3. `apps/web/src/app/api/inbox/reorder/route.ts`** — Bulk position update on drag-end:
- `PATCH`: Auth check. Parse body as `ReorderPayload`. Build bulkOps array following Getmany pattern (research Pattern 3):
  - For destination column: map `cardIds` to updateOne ops setting `{ stage, position: index }`. If `movedCard.cardId` matches, also set `stageChangedAt: new Date()`.
  - If `sourceColumn` provided (cross-column move): push additional updateOne ops for source column `cardIds` with `{ stage: sourceColumn.stage, position: index }`.
  - Execute `PipelineCard.bulkWrite(bulkOps)`. Return `{ success: true }`.

**4. `apps/web/src/app/api/inbox/[id]/notes/route.ts`** — Notes CRUD:
- `GET`: Auth check. Verify card belongs to user via `PipelineCard.findOne({ _id: cardId, userId })`. Find notes `PipelineCardNote.find({ cardId }).sort({ createdAt: -1 }).lean()`. Return `{ notes }`.
- `POST`: Auth check. Verify card belongs to user. Parse `{ content }` from body (validate content is non-empty string, max 2000 chars). Create `PipelineCardNote.create({ cardId, userId, content })`. Return `{ note }` with status 201.

All routes: validate `mongoose.isValidObjectId()` for id params before querying to prevent CastError.
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to confirm no type errors. Verify all route files export the correct HTTP method handlers.
  </verify>
  <done>
8 API endpoints functional: GET/POST /api/inbox, GET/PATCH/DELETE /api/inbox/[id], PATCH /api/inbox/reorder, GET/POST /api/inbox/[id]/notes. All use Clerk auth, dbConnect, and follow existing project patterns. Reorder uses bulkWrite for atomic position updates.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes with no errors
2. All 4 API route files export correct HTTP method handlers
3. PipelineCard model has unique compound index on `{ userId, entityType, entityId }`
4. Stage constants export STAGE_ORDER with 6 stages
5. Types file exports PipelineCardData, PipelineNoteData, ReorderPayload
</verification>

<success_criteria>
- PipelineCard and PipelineCardNote models exist with correct schemas and indexes
- Pipeline stage constants shared between FE/BE with labels, colors, and icons
- TypeScript types exported for all inbox data structures
- 8 API endpoints handle full CRUD + reorder + notes lifecycle
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/22-crm-pipeline-procurement-inbox/22-01-SUMMARY.md`
</output>
