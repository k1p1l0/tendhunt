---
phase: 13-buyer-data-enrichment
plan: 05
type: execute
wave: 5
depends_on: ["13-04"]
files_modified:
  - workers/enrichment/src/stages/06-score.ts
  - workers/enrichment/src/enrichment-engine.ts
  - workers/enrichment/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Stage 6 computes enrichmentScore (0-100) based on data completeness"
    - "All 6 stages wired into enrichment engine and execute in order"
    - "Pipeline completes all stages across multiple Worker invocations"
    - "Enrichment score reflects weighted sum of available data (orgType, governance URLs, personnel count, etc.)"
  artifacts:
    - path: "workers/enrichment/src/stages/06-score.ts"
      provides: "Stage 6: compute enrichmentScore and update buyer"
      min_lines: 40
  key_links:
    - from: "workers/enrichment/src/stages/06-score.ts"
      to: "workers/enrichment/src/db/key-personnel.ts"
      via: "getKeyPersonnelCount"
      pattern: "getKeyPersonnelCount"
    - from: "workers/enrichment/src/stages/06-score.ts"
      to: "workers/enrichment/src/db/board-documents.ts"
      via: "getBoardDocumentCount"
      pattern: "getBoardDocumentCount"
    - from: "workers/enrichment/src/enrichment-engine.ts"
      to: "workers/enrichment/src/stages"
      via: "all 6 stage imports"
      pattern: "classify.*governance.*moderngov.*scrape.*personnel.*score"
---

<objective>
Implement Stage 6 (enrichment scoring) and finalize the complete pipeline wiring so all 6 stages execute sequentially across daily Worker invocations.

Purpose: Stage 6 computes a weighted enrichmentScore (0-100) for each buyer based on data completeness, giving users a quick indicator of how much intelligence is available for each buyer. This plan also ensures all 6 stages are properly wired and the pipeline handles stage transitions correctly.

Output: Complete enrichment pipeline with scoring and all stages wired.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-buyer-data-enrichment/13-RESEARCH.md
@.planning/phases/13-buyer-data-enrichment/13-04-SUMMARY.md

# All stages must be registered
@workers/enrichment/src/enrichment-engine.ts
@workers/enrichment/src/stages/01-classify.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stage 6 (enrichment scoring) and finalize pipeline wiring</name>
  <files>
workers/enrichment/src/stages/06-score.ts
workers/enrichment/src/enrichment-engine.ts
workers/enrichment/src/index.ts
  </files>
  <action>
**workers/enrichment/src/stages/06-score.ts:**

```typescript
export async function computeEnrichmentScores(
  db: Db, env: Env, job: EnrichmentJobDoc, maxItems: number
): Promise<{ processed: number; errors: number; done: boolean }>
```

Logic:
1. Process ALL buyers in batches of 100 (cursor-based):
   - No orgType filter -- score ALL buyers (even unmatched ones get a low score)
   - For each buyer in batch:
     a. Look up counts from related collections:
        - keyPersonnelCount = count from KeyPersonnel where buyerId = buyer._id
        - boardDocumentCount = count from BoardDocument where buyerId = buyer._id
     b. Compute weighted enrichment score:

```typescript
function computeEnrichmentScore(buyer: BuyerDoc, personnelCount: number, docCount: number): number {
  const weights: [string | number, number][] = [
    [buyer.orgType ? 1 : 0, 15],              // Has orgType classification
    [buyer.democracyPortalUrl ? 1 : 0, 10],   // Has governance portal URL
    [buyer.boardPapersUrl ? 1 : 0, 10],       // Has board papers URL
    [buyer.website ? 1 : 0, 5],               // Has website
    [buyer.description ? 1 : 0, 5],           // Has description
    [buyer.staffCount ? 1 : 0, 10],           // Has staff count
    [buyer.annualBudget ? 1 : 0, 10],         // Has annual budget
    [Math.min(personnelCount, 5) / 5, 20],    // Key personnel (up to 5 = full score)
    [Math.min(docCount, 10) / 10, 15],        // Board documents (up to 10 = full score)
  ];

  let score = 0;
  for (const [value, weight] of weights) {
    score += (typeof value === "number" ? value : 0) * weight;
  }
  return Math.round(score);
}
```

     c. Update buyer with: enrichmentScore, enrichmentVersion: (current + 1), lastEnrichedAt: new Date()
   - Bulk update batch
2. Save cursor after each batch

**Optimize counts query:** For each batch, do two aggregate queries to get counts for all buyers in the batch at once, instead of individual count queries:

```typescript
// Batch count lookup
const personnelCounts = await db.collection("keypersonnel").aggregate([
  { $match: { buyerId: { $in: batchIds } } },
  { $group: { _id: "$buyerId", count: { $sum: 1 } } }
]).toArray();

const docCounts = await db.collection("boarddocuments").aggregate([
  { $match: { buyerId: { $in: batchIds } } },
  { $group: { _id: "$buyerId", count: { $sum: 1 } } }
]).toArray();
```

Convert to Maps for O(1) lookup per buyer.

**workers/enrichment/src/enrichment-engine.ts -- FINAL WIRING:**
Ensure ALL 6 stages are registered in the stage map with correct ordering:

```typescript
const STAGE_ORDER: EnrichmentStage[] = [
  "classify",
  "governance_urls",
  "moderngov",
  "scrape",
  "personnel",
  "score",
];

const STAGE_HANDLERS: Record<EnrichmentStage, StageFn> = {
  classify: classifyBuyers,
  governance_urls: mapGovernanceUrls,
  moderngov: fetchModernGovData,
  scrape: scrapeGovernancePages,
  personnel: extractKeyPersonnel,
  score: computeEnrichmentScores,
};
```

Verify the processEnrichmentPipeline function:
1. Gets ALL EnrichmentJob documents
2. Finds the first stage in STAGE_ORDER that is NOT "complete"
3. If no incomplete stage, all enrichment is done -- log and return
4. Calls the appropriate handler
5. If the handler returns done=true, marks the job as complete and returns (next invocation will start next stage)

**workers/enrichment/src/index.ts -- Add logging summary:**
After processEnrichmentPipeline returns, log a summary:
```
Enrichment: stage={stage}, processed={processed}, errors={errors}, done={done}
```

If all stages complete, log: "All enrichment stages complete. Pipeline finished."
  </action>
  <verify>
```bash
cd workers/enrichment && npx tsc --noEmit
```

Verify all 6 stages are wired:
```bash
grep "import.*classify\|import.*mapGovernance\|import.*fetchModernGov\|import.*scrapeGovernance\|import.*extractKeyPersonnel\|import.*computeEnrichment" workers/enrichment/src/enrichment-engine.ts
```

Verify score weights sum to 100:
```bash
grep -c "weight" workers/enrichment/src/stages/06-score.ts
```
  </verify>
  <done>
- Stage 6 computes enrichmentScore (0-100) based on weighted data completeness
- Aggregated count queries for efficient batch scoring
- All 6 stages registered in enrichment engine with correct order
- Pipeline processes stages sequentially, transitioning to next stage on completion
- Worker logs clear summaries per invocation
- Score weights: orgType(15) + governance(10) + boardPapers(10) + website(5) + description(5) + staff(10) + budget(10) + personnel(20) + docs(15) = 100
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd workers/enrichment && npx tsc --noEmit`
2. All 6 stages registered in STAGE_ORDER and STAGE_HANDLERS
3. Enrichment score weights sum to 100
4. Score computation uses batch aggregate queries (not individual counts)
5. Pipeline handles "all stages complete" gracefully
6. Worker entry point logs meaningful summaries
</verification>

<success_criteria>
- Stage 6 computes enrichment scores reflecting data completeness
- All 6 stages execute in order across daily Worker invocations
- Pipeline is fully resumable (cursor-based within stages, stage progression across invocations)
- Complete enrichment Worker ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/13-buyer-data-enrichment/13-05-SUMMARY.md` documenting:
- Enrichment score formula and weights
- Pipeline stage order and transition logic
- Final enrichment-engine.ts architecture
- Files modified
</output>
