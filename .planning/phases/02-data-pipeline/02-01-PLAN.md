---
phase: 02-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/db.ts
  - scripts/lib/api-client.ts
  - scripts/lib/ocds-mapper.ts
  - scripts/ingest-fat.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "200-500 real contract notices from Find a Tender OCDS API exist in the MongoDB contracts collection"
    - "Each ingested contract has source set to FIND_A_TENDER with a valid sourceUrl"
    - "Running the ingestion script again does not create duplicate records (idempotent upsert)"
    - "Contracts have mapped fields: title, buyerName, cpvCodes, sector, publishedDate, deadlineDate"
  artifacts:
    - path: "scripts/lib/db.ts"
      provides: "MongoDB connection for scripts using dbConnect from src/lib/mongodb.ts"
      min_lines: 5
    - path: "scripts/lib/api-client.ts"
      provides: "Rate-limited fetch with retry and cursor-based pagination"
      exports: ["fetchAllReleases", "fetchWithRetry"]
      min_lines: 40
    - path: "scripts/lib/ocds-mapper.ts"
      provides: "OCDS release to Contract document mapper with CPV-to-sector mapping"
      exports: ["mapOcdsToContract", "deriveSectorFromCpv"]
      min_lines: 60
    - path: "scripts/ingest-fat.ts"
      provides: "Find a Tender OCDS API ingestion script"
      min_lines: 40
    - path: "package.json"
      provides: "npm scripts for running ingestion"
      contains: "ingest:fat"
  key_links:
    - from: "scripts/ingest-fat.ts"
      to: "scripts/lib/ocds-mapper.ts"
      via: "mapOcdsToContract import"
      pattern: "import.*mapOcdsToContract.*from"
    - from: "scripts/ingest-fat.ts"
      to: "scripts/lib/api-client.ts"
      via: "fetchAllReleases import"
      pattern: "import.*fetchAllReleases.*from"
    - from: "scripts/ingest-fat.ts"
      to: "src/models/contract.ts"
      via: "Contract model for bulkWrite upsert"
      pattern: "Contract\\.bulkWrite"
    - from: "scripts/lib/ocds-mapper.ts"
      to: "src/models/contract.ts"
      via: "IContract type for return shape"
      pattern: "IContract"
---

<objective>
Create the shared ingestion library (DB connection, rate-limited API client, OCDS-to-Contract mapper with CPV sector classification) and the Find a Tender OCDS API ingestion script that fetches 200-500 real UK procurement contract notices and upserts them into MongoDB.

Purpose: This is the foundation of the data pipeline. Find a Tender is the primary UK above-threshold procurement data source. The shared lib is reused by Plan 02-02 (Contracts Finder) and Plan 02-03 (seed scripts).
Output: Runnable `npm run ingest:fat` that populates the contracts collection with real UK procurement data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-pipeline/02-RESEARCH.md
@src/models/contract.ts
@src/lib/mongodb.ts
@tsconfig.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared scripts library (DB, API client, OCDS mapper)</name>
  <files>
    scripts/lib/db.ts
    scripts/lib/api-client.ts
    scripts/lib/ocds-mapper.ts
  </files>
  <action>
Create three shared library files under `scripts/lib/`:

**scripts/lib/db.ts** -- Database connection wrapper for scripts:
- Import `mongoose` directly (not from src/lib/mongodb.ts -- scripts run outside Next.js)
- Read `MONGODB_URI` from `process.env` (tsx with `--env-file=.env.local` loads env vars automatically)
- Export `connectDB()` that calls `mongoose.connect(MONGODB_URI)` and logs "Connected to MongoDB"
- Export `disconnectDB()` that calls `mongoose.disconnect()`
- Throw a clear error if `MONGODB_URI` is not set

**scripts/lib/api-client.ts** -- Rate-limited fetch with retry and cursor pagination:
- Export `fetchWithRetry(url: string, maxRetries = 3): Promise<Response>` -- retries on 429/403/503, reads `Retry-After` header (default 60s for 429, 300s for 403), logs warning on each retry
- Export `fetchAllReleases(baseUrl: string, params: Record<string, string>, maxItems = 500): Promise<any[]>` -- cursor-based pagination, 100 items per page, 500ms delay between requests, stops when cursor is empty or maxItems reached
- Use Node.js built-in `fetch` (no external dependencies)
- Add a `sleep(ms)` utility function

**scripts/lib/ocds-mapper.ts** -- OCDS release to Contract document mapper:
- Export `mapOcdsToContract(release: OcdsRelease, source: "FIND_A_TENDER" | "CONTRACTS_FINDER"): Partial<IContract>` that maps:
  - `ocid` from `release.ocid`
  - `noticeId` from `release.id`
  - `source` from parameter
  - `sourceUrl` constructed from source + noticeId (FaT: `https://www.find-tender.service.gov.uk/Notice/{id}`, CF: `https://www.contractsfinder.service.gov.uk/Notice/{id}`)
  - `title` from `release.tender?.title` (fallback: "Untitled")
  - `description` from `release.tender?.description`
  - `status` mapped via helper: tender status "active"/"open" -> "OPEN", "closed"/"complete" -> "CLOSED", "cancelled" -> "CANCELLED", "awarded" -> "AWARDED", default -> "OPEN"
  - `stage` mapped from `release.tag[]`: includes "planning" -> "PLANNING", includes "award" -> "AWARD", default -> "TENDER"
  - `buyerName` from `release.parties[]` where role includes "buyer", fallback to `release.buyer?.name`, fallback to "Unknown"
  - `buyerRegion` from buyer party `address.region`
  - `cpvCodes` from `release.tender?.items[]?.classification?.id` (filter out nulls). Also check `release.tender?.classification?.id` as a top-level CPV code
  - `sector` via `deriveSectorFromCpv(cpvCodes[0])`
  - `valueMin` and `valueMax` from `release.tender?.value?.amount` (same for both since OCDS gives a single amount)
  - `currency` from `release.tender?.value?.currency` (default "GBP")
  - `publishedDate` from `release.date`
  - `deadlineDate` from `release.tender?.tenderPeriod?.endDate`
  - `rawData` stores the original release object
- Define a TypeScript `OcdsRelease` interface with all the fields used above (all nested fields optional)
- Export `deriveSectorFromCpv(cpvCode?: string): string | undefined` using the 2-digit CPV division map from research (all ~35 sectors)
- Handle ALL optional fields with null-safe access (`?.`) -- Contracts Finder has known data quality issues with empty fields

**IMPORTANT path alias note:** Scripts run via tsx OUTSIDE Next.js. Do NOT use `@/` path aliases in scripts. Use relative imports instead:
- `import Contract from '../../src/models/contract'` (not `@/models/contract`)
- For the IContract type, use `import type { IContract } from '../../src/models/contract'`
  </action>
  <verify>
Run `npx tsc --noEmit scripts/lib/db.ts scripts/lib/api-client.ts scripts/lib/ocds-mapper.ts` (or verify TypeScript compiles without errors by checking types manually). Confirm all three files exist with correct exports.
  </verify>
  <done>
Three library files exist under scripts/lib/ with typed exports: connectDB/disconnectDB, fetchWithRetry/fetchAllReleases, mapOcdsToContract/deriveSectorFromCpv. All use relative imports (not @/ aliases). OcdsRelease interface covers both Find a Tender and Contracts Finder response shapes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Find a Tender ingestion script and npm scripts</name>
  <files>
    scripts/ingest-fat.ts
    package.json
  </files>
  <action>
**scripts/ingest-fat.ts** -- Find a Tender OCDS API ingestion:
- Import `connectDB`, `disconnectDB` from `./lib/db`
- Import `fetchAllReleases` from `./lib/api-client`
- Import `mapOcdsToContract` from `./lib/ocds-mapper`
- Import `Contract` from `../../src/models/contract` (relative path, not @/)
- Main function flow:
  1. Call `connectDB()`
  2. Set `baseUrl = "https://www.find-tender.service.gov.uk/api/1.0/ocdsReleasePackages"`
  3. Set params: `stages: "tender"`, `updatedFrom: 30 days ago in ISO format (YYYY-MM-DDTHH:MM:SS)`
  4. Call `fetchAllReleases(baseUrl, params, 500)` to get up to 500 releases
  5. Map each release through `mapOcdsToContract(release, "FIND_A_TENDER")`
  6. Filter out any contracts where title is missing or "Untitled" AND description is empty (skip garbage records)
  7. Build `bulkWrite` operations array with `updateOne` + `upsert: true`, filter by `{ source: doc.source, noticeId: doc.noticeId }`
  8. Execute `Contract.bulkWrite(ops, { ordered: false })`
  9. Log summary: `Fetched: X releases, Mapped: Y contracts, Upserted: Z, Updated: W`
  10. Call `disconnectDB()`
- Wrap everything in try/catch, log errors, ensure `disconnectDB()` runs in finally block
- Add `console.time("ingest-fat")` / `console.timeEnd("ingest-fat")` for timing
- Call the main function immediately (script is run directly, not imported)

**package.json** -- Add npm scripts (EDIT existing package.json, do not rewrite):
- Add `"ingest:fat": "tsx --env-file=.env.local scripts/ingest-fat.ts"` to scripts
- Add `"ingest:cf": "tsx --env-file=.env.local scripts/ingest-cf.ts"` to scripts (placeholder for Plan 02-02)
- Add `"seed:signals": "tsx --env-file=.env.local scripts/seed-signals.ts"` to scripts (placeholder for Plan 02-03)
- Add `"seed:buyers": "tsx --env-file=.env.local scripts/seed-buyers.ts"` to scripts (placeholder for Plan 02-03)
- Add `"tsx"` as a devDependency if not already present: `npm install -D tsx`

**CRITICAL: Test the script** after creating it:
1. Run `npm run ingest:fat`
2. Verify it connects to MongoDB, fetches releases, and upserts contracts
3. Check MongoDB for ingested records: run a quick count query
4. If the Find a Tender API is unreachable or returns errors, log the response and handle gracefully (the API may have changed post-Procurement Act 2023 -- check the actual response structure and adapt the mapper if needed)
5. Run the script a SECOND time to verify idempotency (upsertedCount should be 0, modifiedCount should equal the number of records)
  </action>
  <verify>
`npm run ingest:fat` completes successfully. MongoDB contracts collection contains 200+ documents with `source: "FIND_A_TENDER"`. Running the script again shows modifiedCount > 0 and upsertedCount = 0 (idempotent). Each contract has: title, buyerName, noticeId, source, sourceUrl, publishedDate.
  </verify>
  <done>
Find a Tender ingestion script works end-to-end: fetches 200-500 real contract notices from the OCDS API, maps them to the Contract schema with proper source attribution, and upserts them idempotently into MongoDB. npm scripts are defined for all four data pipeline commands.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `ls scripts/lib/` shows db.ts, api-client.ts, ocds-mapper.ts
2. `ls scripts/` shows ingest-fat.ts
3. `npm run ingest:fat` fetches and upserts 200+ real contracts
4. MongoDB contracts collection has documents with source="FIND_A_TENDER", valid titles, buyerNames, and dates
5. Re-running the script is idempotent (no duplicates created)
</verification>

<success_criteria>
- 200-500 real Find a Tender contract notices in MongoDB
- Each contract has source="FIND_A_TENDER" and a valid sourceUrl
- Shared library (db, api-client, ocds-mapper) is reusable for Plan 02-02
- npm scripts defined: ingest:fat, ingest:cf (placeholder), seed:signals (placeholder), seed:buyers (placeholder)
- Script is idempotent (safe to re-run)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-pipeline/02-01-SUMMARY.md`
</output>
