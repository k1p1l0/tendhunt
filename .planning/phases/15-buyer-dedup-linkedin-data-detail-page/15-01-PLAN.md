---
phase: 15-buyer-dedup-linkedin-data-detail-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/nuts-regions.ts
  - src/models/contract.ts
  - workers/data-sync/src/db/buyers.ts
  - workers/data-sync/src/db/contracts.ts
  - workers/data-sync/src/sync-engine.ts
  - workers/data-sync/src/types.ts
  - scripts/backfill-buyer-ids.ts
autonomous: true

must_haves:
  truths:
    - "Contract schema has buyerId field referencing Buyer collection with an index"
    - "autoExtractBuyers returns Map<nameLower, ObjectId> so sync engine can set buyerId on contracts"
    - "upsertContracts accepts and stores buyerId on each contract document"
    - "Backfill script resolves buyerId for all existing 59K contracts by nameLower matching"
    - "NUTS region codes can be resolved to human-readable names via resolveRegionName()"
    - "Static NUTS mapping covers levels 0-3 including both 2016 and 2021 Scotland codes (~250 entries)"
  artifacts:
    - path: "src/lib/nuts-regions.ts"
      provides: "Static NUTS code to human name mapping with hierarchical fallback resolver"
      exports: ["NUTS_REGIONS", "resolveRegionName"]
    - path: "src/models/contract.ts"
      provides: "Contract schema with buyerId ObjectId field and index"
      contains: "buyerId"
    - path: "workers/data-sync/src/db/buyers.ts"
      provides: "autoExtractBuyers returning buyerIdMap"
      exports: ["autoExtractBuyers"]
    - path: "workers/data-sync/src/db/contracts.ts"
      provides: "upsertContracts accepting buyerIdMap parameter"
      exports: ["upsertContracts"]
    - path: "workers/data-sync/src/sync-engine.ts"
      provides: "Sync engine wiring buyerIdMap from autoExtractBuyers to upsertContracts"
    - path: "scripts/backfill-buyer-ids.ts"
      provides: "One-time backfill script for existing contracts"
  key_links:
    - from: "workers/data-sync/src/sync-engine.ts"
      to: "workers/data-sync/src/db/buyers.ts"
      via: "autoExtractBuyers returns buyerIdMap"
      pattern: "buyerIdMap"
    - from: "workers/data-sync/src/sync-engine.ts"
      to: "workers/data-sync/src/db/contracts.ts"
      via: "passes buyerIdMap to upsertContracts"
      pattern: "upsertContracts.*buyerIdMap"
    - from: "scripts/backfill-buyer-ids.ts"
      to: "src/models/buyer.ts"
      via: "queries all buyers for nameLower->_id map"
      pattern: "Buyer\\.find"
    - from: "scripts/backfill-buyer-ids.ts"
      to: "src/models/contract.ts"
      via: "bulkWrite sets buyerId on contracts"
      pattern: "Contract\\.bulkWrite"
---

<objective>
Add buyerId ObjectId reference to Contract schema, modify data-sync worker to forward-write buyerId on new contracts, create NUTS region code static mapping module, and create backfill script for existing 59K contracts.

Purpose: Establishes the data foundation for contract-buyer entity linking (replacing fragile buyerName string matching) and provides the NUTS code humanization utility needed by all display components.

Output: Contract schema with buyerId, modified data-sync worker pipeline, NUTS mapping module, backfill script ready to run.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-buyer-dedup-linkedin-data-detail-page/15-RESEARCH.md
@src/models/contract.ts
@src/models/buyer.ts
@workers/data-sync/src/db/buyers.ts
@workers/data-sync/src/db/contracts.ts
@workers/data-sync/src/sync-engine.ts
@workers/data-sync/src/types.ts
@scripts/backfill-buyer-websites.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: NUTS region mapping module + Contract schema buyerId field</name>
  <files>src/lib/nuts-regions.ts, src/models/contract.ts</files>
  <action>
1. Create `src/lib/nuts-regions.ts` with a comprehensive static NUTS code mapping:
   - Export `NUTS_REGIONS: Record<string, string>` with ~250 entries covering NUTS levels 0-3 for the UK
   - Level 0: UK -> "United Kingdom"
   - Level 1: 12 standard UK regions (UKC through UKN) -- use the names from the existing `REGIONS` constant in `contract-filters.tsx` for consistency (e.g., UKI -> "London", UKM -> "Scotland")
   - Level 2: ~41 sub-regions (UKC1 -> "Tees Valley and Durham", UKD3 -> "Greater Manchester", UKI3 -> "Inner London - West", UKM8 -> "West Central Scotland", etc.)
   - Level 3: ~179 districts (UKM82 -> "Glasgow City", UKE41 -> "Bradford", UKI31 -> "Camden and City of London", etc.)
   - MUST include BOTH NUTS 2016 Scotland codes (UKM1-M4 sub-codes ~20 entries) AND NUTS 2021 codes (UKM5-M9 sub-codes) -- Find a Tender uses 2021 but older data may have 2016
   - MUST include BOTH London 2016 codes (UKI1/UKI2) AND 2021 codes (UKI3-UKI7)
   - Export `resolveRegionName(code: string | null | undefined): string` function that:
     - Returns "Not specified" for null/undefined/empty
     - Tries exact match in NUTS_REGIONS first
     - Falls back to progressively shorter codes (UKE41 -> UKE4 -> UKE -> UK)
     - Returns raw code as final fallback if nothing matches

   Use the full mapping data from the research document (15-RESEARCH.md sections "Key Scotland Mapping" and "Key London Mapping"). For the complete list beyond what's in research, use official NUTS 2021 classification for UK (the research confirms ~233 entries for 2021 + ~20 for 2016 Scotland/London).

2. Modify `src/models/contract.ts`:
   - Add `buyerId` field to contractSchema after buyerRegion: `buyerId: { type: Schema.Types.ObjectId, ref: 'Buyer', index: true }`
   - This creates an indexed ObjectId reference to the Buyer collection
   - The `ref: 'Buyer'` enables future `.populate()` if needed but we will NOT use populate (manual lookup is more explicit)
   - The index is critical for the buyer detail page which queries `Contract.find({ buyerId: buyerObjectId })`
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no type errors)
    - `node -e "const { resolveRegionName, NUTS_REGIONS } = require('./src/lib/nuts-regions'); console.log(Object.keys(NUTS_REGIONS).length); console.log(resolveRegionName('UKM82')); console.log(resolveRegionName('UKD3')); console.log(resolveRegionName('UKI')); console.log(resolveRegionName(null));"` outputs count > 200, "Glasgow City", "Greater Manchester", "London", "Not specified"
    - Contract schema includes buyerId field with index
  </verify>
  <done>
    - NUTS_REGIONS has 230+ entries covering levels 0-3 with both 2016 and 2021 Scotland/London codes
    - resolveRegionName correctly resolves exact matches, falls back hierarchically, handles null
    - Contract schema has `buyerId: ObjectId` with `ref: 'Buyer'` and `index: true`
  </done>
</task>

<task type="auto">
  <name>Task 2: Data-sync worker buyerId forward-write + backfill script</name>
  <files>workers/data-sync/src/db/buyers.ts, workers/data-sync/src/db/contracts.ts, workers/data-sync/src/sync-engine.ts, workers/data-sync/src/types.ts, scripts/backfill-buyer-ids.ts</files>
  <action>
1. Modify `workers/data-sync/src/types.ts`:
   - Add optional `buyerId` to `MappedContract` interface: `buyerId?: ObjectId | null`
   - Import ObjectId from mongodb if not already imported (it is already imported)

2. Modify `workers/data-sync/src/db/buyers.ts` -- change `autoExtractBuyers` return type:
   - Change return type from `Promise<number>` to `Promise<{ created: number; buyerIdMap: Map<string, ObjectId> }>`
   - After the existing `bulkWrite`, add a follow-up query to get ALL buyer IDs (not just upserted):
     ```
     const allNameKeys = Array.from(uniqueByName.keys());
     const buyerDocs = await collection
       .find({ nameLower: { $in: allNameKeys } }, { projection: { _id: 1, nameLower: 1 } })
       .toArray();
     const buyerIdMap = new Map<string, ObjectId>();
     for (const doc of buyerDocs) {
       buyerIdMap.set(doc.nameLower, doc._id);
     }
     ```
   - Return `{ created: result.upsertedCount, buyerIdMap }` instead of just `result.upsertedCount`
   - CRITICAL: The follow-up find() is necessary because bulkWrite only returns upsertedIds for NEW docs, not matched/existing ones. Most buyers will already exist, so we need the find() to get their IDs too.

3. Modify `workers/data-sync/src/db/contracts.ts` -- accept buyerIdMap:
   - Change `upsertContracts` signature to accept optional third parameter: `buyerIdMap?: Map<string, ObjectId>`
   - Inside the ops map, before creating the updateOne, resolve buyerId:
     ```
     const nameLower = doc.buyerName?.toLowerCase().trim();
     const buyerId = (nameLower && buyerIdMap?.get(nameLower)) || null;
     ```
   - Add `buyerId` to the `$set` spread: `$set: { ...doc, buyerId, updatedAt: new Date() }`
   - Import ObjectId from mongodb

4. Modify `workers/data-sync/src/sync-engine.ts` -- wire buyerIdMap through:
   - In `processSyncJob`, where `autoExtractBuyers` is called (line ~107), change:
     - From: `await autoExtractBuyers(db, batch);`
     - To: `const { buyerIdMap } = await autoExtractBuyers(db, batch);`
   - Pass buyerIdMap to upsertContracts:
     - From: `await upsertContracts(db, batch);`
     - To: `await upsertContracts(db, batch, buyerIdMap);`
   - Note: upsertContracts is called BEFORE autoExtractBuyers currently (line 106-107). The order must be REVERSED: extract buyers FIRST (to get IDs), THEN upsert contracts (with IDs). Change the order so autoExtractBuyers runs before upsertContracts.

5. Create `scripts/backfill-buyer-ids.ts` -- one-time backfill for existing 59K contracts:
   - Follow the pattern from `scripts/backfill-buyer-websites.ts` (dbConnect, Buyer.find, Map, batch loop)
   - Step 1: Query all buyers with nameLower field: `Buyer.find({ nameLower: { $exists: true } }).select("_id nameLower").lean()`
   - Step 2: Build `Map<string, ObjectId>` from nameLower -> _id
   - Step 3: Process contracts in batches of 1000 that don't have buyerId yet: `Contract.find({ buyerId: { $exists: false } }).select("_id buyerName").skip(skip).limit(1000).lean()`
   - Step 4: For each contract, normalize `buyerName.toLowerCase().trim()`, look up in map, build updateOne op with `$set: { buyerId }`
   - Step 5: `Contract.bulkWrite(ops)` for the batch
   - Step 6: Log progress: contracts processed, updated, unmatched
   - Step 7: At end, log summary: total processed, total matched, total unmatched (unmatched = no buyer found for that buyerName)
   - Usage comment: `DOTENV_CONFIG_PATH=.env.local npx tsx --require dotenv/config scripts/backfill-buyer-ids.ts`
  </action>
  <verify>
    - `npx tsc --noEmit` passes for both main project and `cd workers/data-sync && npx tsc --noEmit`
    - `autoExtractBuyers` return type is `{ created: number; buyerIdMap: Map<string, ObjectId> }`
    - `upsertContracts` accepts optional `buyerIdMap` parameter
    - sync-engine calls autoExtractBuyers BEFORE upsertContracts and passes buyerIdMap
    - `scripts/backfill-buyer-ids.ts` file exists and compiles without errors
  </verify>
  <done>
    - Data-sync worker forward-writes buyerId on every new contract from both FaT and CF sources
    - autoExtractBuyers returns buyerIdMap with all buyer ObjectIds (new and existing)
    - upsertContracts stores buyerId on each contract document via nameLower lookup
    - Backfill script ready to run against existing 59K contracts (matches by normalized buyerName)
    - Sync engine order is: map releases -> extract buyers (get IDs) -> upsert contracts (with IDs)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit` in root and `cd workers/data-sync && npx tsc --noEmit`
2. NUTS mapping has 230+ entries and resolves UKM82, UKD3, UKI, null correctly
3. Contract schema has buyerId with ObjectId type, ref, and index
4. Data-sync pipeline: autoExtractBuyers -> buyerIdMap -> upsertContracts(batch, buyerIdMap)
5. Backfill script compiles and follows established pattern from backfill-buyer-websites.ts
</verification>

<success_criteria>
- Contract schema includes indexed buyerId ObjectId field referencing Buyer
- NUTS_REGIONS mapping covers 230+ UK region codes at all levels with hierarchical fallback
- Data-sync worker forward-writes buyerId on every newly synced contract
- Backfill script exists and is ready to run for existing 59K contracts
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/15-buyer-dedup-linkedin-data-detail-page/15-01-SUMMARY.md`
</output>
